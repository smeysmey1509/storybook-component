{"version":3,"file":"vendors-node_modules_storybook_blocks_dist_index_mjs.b0fdefb17a50cda61957.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA4BA","sources":["webpack://storybook/./node_modules/@storybook/core/dist/docs-tools/index.js"],"sourcesContent":["var zs = Object.create;\nvar yt = Object.defineProperty;\nvar Ws = Object.getOwnPropertyDescriptor;\nvar Xs = Object.getOwnPropertyNames;\nvar Qs = Object.getPrototypeOf, Zs = Object.prototype.hasOwnProperty;\nvar r = (e, n) => yt(e, \"name\", { value: n, configurable: !0 });\nvar l = (e, n) => () => (n || e((n = { exports: {} }).exports, n), n.exports);\nvar ep = (e, n, a, s) => {\n  if (n && typeof n == \"object\" || typeof n == \"function\")\n    for (let p of Xs(n))\n      !Zs.call(e, p) && p !== a && yt(e, p, { get: () => n[p], enumerable: !(s = Ws(n, p)) || s.enumerable });\n  return e;\n};\nvar pr = (e, n, a) => (a = e != null ? zs(Qs(e)) : {}, ep(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  n || !e || !e.__esModule ? yt(a, \"default\", { value: e, enumerable: !0 }) : a,\n  e\n));\n\n// ../node_modules/lodash/_freeGlobal.js\nvar dt = l((xT, ur) => {\n  var cp = typeof global == \"object\" && global && global.Object === Object && global;\n  ur.exports = cp;\n});\n\n// ../node_modules/lodash/_root.js\nvar L = l((bT, lr) => {\n  var up = dt(), lp = typeof self == \"object\" && self && self.Object === Object && self, fp = up || lp || Function(\"return this\")();\n  lr.exports = fp;\n});\n\n// ../node_modules/lodash/_Symbol.js\nvar he = l((vT, fr) => {\n  var yp = L(), dp = yp.Symbol;\n  fr.exports = dp;\n});\n\n// ../node_modules/lodash/_getRawTag.js\nvar Tr = l((wT, mr) => {\n  var yr = he(), dr = Object.prototype, mp = dr.hasOwnProperty, Tp = dr.toString, xe = yr ? yr.toStringTag : void 0;\n  function gp(e) {\n    var n = mp.call(e, xe), a = e[xe];\n    try {\n      e[xe] = void 0;\n      var s = !0;\n    } catch {\n    }\n    var p = Tp.call(e);\n    return s && (n ? e[xe] = a : delete e[xe]), p;\n  }\n  r(gp, \"getRawTag\");\n  mr.exports = gp;\n});\n\n// ../node_modules/lodash/_objectToString.js\nvar hr = l((JT, gr) => {\n  var hp = Object.prototype, xp = hp.toString;\n  function bp(e) {\n    return xp.call(e);\n  }\n  r(bp, \"objectToString\");\n  gr.exports = bp;\n});\n\n// ../node_modules/lodash/_baseGetTag.js\nvar ne = l((ET, vr) => {\n  var xr = he(), vp = Tr(), wp = hr(), Pp = \"[object Null]\", Jp = \"[object Undefined]\", br = xr ? xr.toStringTag : void 0;\n  function Sp(e) {\n    return e == null ? e === void 0 ? Jp : Pp : br && br in Object(e) ? vp(e) : wp(e);\n  }\n  r(Sp, \"baseGetTag\");\n  vr.exports = Sp;\n});\n\n// ../node_modules/lodash/isObject.js\nvar Ce = l((AT, wr) => {\n  function Ep(e) {\n    var n = typeof e;\n    return e != null && (n == \"object\" || n == \"function\");\n  }\n  r(Ep, \"isObject\");\n  wr.exports = Ep;\n});\n\n// ../node_modules/lodash/isFunction.js\nvar mt = l((_T, Pr) => {\n  var Op = ne(), Ap = Ce(), Np = \"[object AsyncFunction]\", _p = \"[object Function]\", Dp = \"[object GeneratorFunction]\", qp = \"[object Proxy]\";\n  function Ip(e) {\n    if (!Ap(e))\n      return !1;\n    var n = Op(e);\n    return n == _p || n == Dp || n == Np || n == qp;\n  }\n  r(Ip, \"isFunction\");\n  Pr.exports = Ip;\n});\n\n// ../node_modules/lodash/_coreJsData.js\nvar Sr = l((qT, Jr) => {\n  var Rp = L(), jp = Rp[\"__core-js_shared__\"];\n  Jr.exports = jp;\n});\n\n// ../node_modules/lodash/_isMasked.js\nvar Ar = l((IT, Or) => {\n  var Tt = Sr(), Er = function() {\n    var e = /[^.]+$/.exec(Tt && Tt.keys && Tt.keys.IE_PROTO || \"\");\n    return e ? \"Symbol(src)_1.\" + e : \"\";\n  }();\n  function Fp(e) {\n    return !!Er && Er in e;\n  }\n  r(Fp, \"isMasked\");\n  Or.exports = Fp;\n});\n\n// ../node_modules/lodash/_toSource.js\nvar gt = l((jT, Nr) => {\n  var Lp = Function.prototype, kp = Lp.toString;\n  function Cp(e) {\n    if (e != null) {\n      try {\n        return kp.call(e);\n      } catch {\n      }\n      try {\n        return e + \"\";\n      } catch {\n      }\n    }\n    return \"\";\n  }\n  r(Cp, \"toSource\");\n  Nr.exports = Cp;\n});\n\n// ../node_modules/lodash/_baseIsNative.js\nvar Dr = l((LT, _r) => {\n  var Up = mt(), Mp = Ar(), Vp = Ce(), Kp = gt(), Bp = /[\\\\^$.*+?()[\\]{}|]/g, $p = /^\\[object .+?Constructor\\]$/, Gp = Function.prototype, Yp = Object.\n  prototype, Hp = Gp.toString, zp = Yp.hasOwnProperty, Wp = RegExp(\n    \"^\" + Hp.call(zp).replace(Bp, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"\n  );\n  function Xp(e) {\n    if (!Vp(e) || Mp(e))\n      return !1;\n    var n = Up(e) ? Wp : $p;\n    return n.test(Kp(e));\n  }\n  r(Xp, \"baseIsNative\");\n  _r.exports = Xp;\n});\n\n// ../node_modules/lodash/_getValue.js\nvar Ir = l((CT, qr) => {\n  function Qp(e, n) {\n    return e?.[n];\n  }\n  r(Qp, \"getValue\");\n  qr.exports = Qp;\n});\n\n// ../node_modules/lodash/_getNative.js\nvar H = l((MT, Rr) => {\n  var Zp = Dr(), ec = Ir();\n  function tc(e, n) {\n    var a = ec(e, n);\n    return Zp(a) ? a : void 0;\n  }\n  r(tc, \"getNative\");\n  Rr.exports = tc;\n});\n\n// ../node_modules/lodash/_defineProperty.js\nvar Fr = l((KT, jr) => {\n  var rc = H(), nc = function() {\n    try {\n      var e = rc(Object, \"defineProperty\");\n      return e({}, \"\", {}), e;\n    } catch {\n    }\n  }();\n  jr.exports = nc;\n});\n\n// ../node_modules/lodash/_baseAssignValue.js\nvar Cr = l((BT, kr) => {\n  var Lr = Fr();\n  function oc(e, n, a) {\n    n == \"__proto__\" && Lr ? Lr(e, n, {\n      configurable: !0,\n      enumerable: !0,\n      value: a,\n      writable: !0\n    }) : e[n] = a;\n  }\n  r(oc, \"baseAssignValue\");\n  kr.exports = oc;\n});\n\n// ../node_modules/lodash/_createBaseFor.js\nvar Mr = l((GT, Ur) => {\n  function ac(e) {\n    return function(n, a, s) {\n      for (var p = -1, c = Object(n), y = s(n), d = y.length; d--; ) {\n        var m = y[e ? d : ++p];\n        if (a(c[m], m, c) === !1)\n          break;\n      }\n      return n;\n    };\n  }\n  r(ac, \"createBaseFor\");\n  Ur.exports = ac;\n});\n\n// ../node_modules/lodash/_baseFor.js\nvar Kr = l((HT, Vr) => {\n  var ic = Mr(), sc = ic();\n  Vr.exports = sc;\n});\n\n// ../node_modules/lodash/_baseTimes.js\nvar $r = l((zT, Br) => {\n  function pc(e, n) {\n    for (var a = -1, s = Array(e); ++a < e; )\n      s[a] = n(a);\n    return s;\n  }\n  r(pc, \"baseTimes\");\n  Br.exports = pc;\n});\n\n// ../node_modules/lodash/isObjectLike.js\nvar oe = l((XT, Gr) => {\n  function cc(e) {\n    return e != null && typeof e == \"object\";\n  }\n  r(cc, \"isObjectLike\");\n  Gr.exports = cc;\n});\n\n// ../node_modules/lodash/_baseIsArguments.js\nvar Hr = l((ZT, Yr) => {\n  var uc = ne(), lc = oe(), fc = \"[object Arguments]\";\n  function yc(e) {\n    return lc(e) && uc(e) == fc;\n  }\n  r(yc, \"baseIsArguments\");\n  Yr.exports = yc;\n});\n\n// ../node_modules/lodash/isArguments.js\nvar ht = l((tg, Xr) => {\n  var zr = Hr(), dc = oe(), Wr = Object.prototype, mc = Wr.hasOwnProperty, Tc = Wr.propertyIsEnumerable, gc = zr(/* @__PURE__ */ function() {\n    return arguments;\n  }()) ? zr : function(e) {\n    return dc(e) && mc.call(e, \"callee\") && !Tc.call(e, \"callee\");\n  };\n  Xr.exports = gc;\n});\n\n// ../node_modules/lodash/isArray.js\nvar M = l((rg, Qr) => {\n  var hc = Array.isArray;\n  Qr.exports = hc;\n});\n\n// ../node_modules/lodash/stubFalse.js\nvar en = l((ng, Zr) => {\n  function xc() {\n    return !1;\n  }\n  r(xc, \"stubFalse\");\n  Zr.exports = xc;\n});\n\n// ../node_modules/lodash/isBuffer.js\nvar xt = l((be, ae) => {\n  var bc = L(), vc = en(), nn = typeof be == \"object\" && be && !be.nodeType && be, tn = nn && typeof ae == \"object\" && ae && !ae.nodeType &&\n  ae, wc = tn && tn.exports === nn, rn = wc ? bc.Buffer : void 0, Pc = rn ? rn.isBuffer : void 0, Jc = Pc || vc;\n  ae.exports = Jc;\n});\n\n// ../node_modules/lodash/_isIndex.js\nvar bt = l((ag, on) => {\n  var Sc = 9007199254740991, Ec = /^(?:0|[1-9]\\d*)$/;\n  function Oc(e, n) {\n    var a = typeof e;\n    return n = n ?? Sc, !!n && (a == \"number\" || a != \"symbol\" && Ec.test(e)) && e > -1 && e % 1 == 0 && e < n;\n  }\n  r(Oc, \"isIndex\");\n  on.exports = Oc;\n});\n\n// ../node_modules/lodash/isLength.js\nvar Ue = l((sg, an) => {\n  var Ac = 9007199254740991;\n  function Nc(e) {\n    return typeof e == \"number\" && e > -1 && e % 1 == 0 && e <= Ac;\n  }\n  r(Nc, \"isLength\");\n  an.exports = Nc;\n});\n\n// ../node_modules/lodash/_baseIsTypedArray.js\nvar pn = l((cg, sn) => {\n  var _c = ne(), Dc = Ue(), qc = oe(), Ic = \"[object Arguments]\", Rc = \"[object Array]\", jc = \"[object Boolean]\", Fc = \"[object Date]\", Lc = \"\\\n[object Error]\", kc = \"[object Function]\", Cc = \"[object Map]\", Uc = \"[object Number]\", Mc = \"[object Object]\", Vc = \"[object RegExp]\", Kc = \"\\\n[object Set]\", Bc = \"[object String]\", $c = \"[object WeakMap]\", Gc = \"[object ArrayBuffer]\", Yc = \"[object DataView]\", Hc = \"[object Float32\\\nArray]\", zc = \"[object Float64Array]\", Wc = \"[object Int8Array]\", Xc = \"[object Int16Array]\", Qc = \"[object Int32Array]\", Zc = \"[object Uint\\\n8Array]\", eu = \"[object Uint8ClampedArray]\", tu = \"[object Uint16Array]\", ru = \"[object Uint32Array]\", E = {};\n  E[Hc] = E[zc] = E[Wc] = E[Xc] = E[Qc] = E[Zc] = E[eu] = E[tu] = E[ru] = !0;\n  E[Ic] = E[Rc] = E[Gc] = E[jc] = E[Yc] = E[Fc] = E[Lc] = E[kc] = E[Cc] = E[Uc] = E[Mc] = E[Vc] = E[Kc] = E[Bc] = E[$c] = !1;\n  function nu(e) {\n    return qc(e) && Dc(e.length) && !!E[_c(e)];\n  }\n  r(nu, \"baseIsTypedArray\");\n  sn.exports = nu;\n});\n\n// ../node_modules/lodash/_baseUnary.js\nvar un = l((lg, cn) => {\n  function ou(e) {\n    return function(n) {\n      return e(n);\n    };\n  }\n  r(ou, \"baseUnary\");\n  cn.exports = ou;\n});\n\n// ../node_modules/lodash/_nodeUtil.js\nvar fn = l((ve, ie) => {\n  var au = dt(), ln = typeof ve == \"object\" && ve && !ve.nodeType && ve, we = ln && typeof ie == \"object\" && ie && !ie.nodeType && ie, iu = we &&\n  we.exports === ln, vt = iu && au.process, su = function() {\n    try {\n      var e = we && we.require && we.require(\"util\").types;\n      return e || vt && vt.binding && vt.binding(\"util\");\n    } catch {\n    }\n  }();\n  ie.exports = su;\n});\n\n// ../node_modules/lodash/isTypedArray.js\nvar wt = l((yg, mn) => {\n  var pu = pn(), cu = un(), yn = fn(), dn = yn && yn.isTypedArray, uu = dn ? cu(dn) : pu;\n  mn.exports = uu;\n});\n\n// ../node_modules/lodash/_arrayLikeKeys.js\nvar gn = l((dg, Tn) => {\n  var lu = $r(), fu = ht(), yu = M(), du = xt(), mu = bt(), Tu = wt(), gu = Object.prototype, hu = gu.hasOwnProperty;\n  function xu(e, n) {\n    var a = yu(e), s = !a && fu(e), p = !a && !s && du(e), c = !a && !s && !p && Tu(e), y = a || s || p || c, d = y ? lu(e.length, String) :\n    [], m = d.length;\n    for (var g in e)\n      (n || hu.call(e, g)) && !(y && // Safari 9 has enumerable `arguments.length` in strict mode.\n      (g == \"length\" || // Node.js 0.10 has enumerable non-index properties on buffers.\n      p && (g == \"offset\" || g == \"parent\") || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n      c && (g == \"buffer\" || g == \"byteLength\" || g == \"byteOffset\") || // Skip index properties.\n      mu(g, m))) && d.push(g);\n    return d;\n  }\n  r(xu, \"arrayLikeKeys\");\n  Tn.exports = xu;\n});\n\n// ../node_modules/lodash/_isPrototype.js\nvar xn = l((Tg, hn) => {\n  var bu = Object.prototype;\n  function vu(e) {\n    var n = e && e.constructor, a = typeof n == \"function\" && n.prototype || bu;\n    return e === a;\n  }\n  r(vu, \"isPrototype\");\n  hn.exports = vu;\n});\n\n// ../node_modules/lodash/_overArg.js\nvar vn = l((hg, bn) => {\n  function wu(e, n) {\n    return function(a) {\n      return e(n(a));\n    };\n  }\n  r(wu, \"overArg\");\n  bn.exports = wu;\n});\n\n// ../node_modules/lodash/_nativeKeys.js\nvar Pn = l((bg, wn) => {\n  var Pu = vn(), Ju = Pu(Object.keys, Object);\n  wn.exports = Ju;\n});\n\n// ../node_modules/lodash/_baseKeys.js\nvar Sn = l((vg, Jn) => {\n  var Su = xn(), Eu = Pn(), Ou = Object.prototype, Au = Ou.hasOwnProperty;\n  function Nu(e) {\n    if (!Su(e))\n      return Eu(e);\n    var n = [];\n    for (var a in Object(e))\n      Au.call(e, a) && a != \"constructor\" && n.push(a);\n    return n;\n  }\n  r(Nu, \"baseKeys\");\n  Jn.exports = Nu;\n});\n\n// ../node_modules/lodash/isArrayLike.js\nvar On = l((Pg, En) => {\n  var _u = mt(), Du = Ue();\n  function qu(e) {\n    return e != null && Du(e.length) && !_u(e);\n  }\n  r(qu, \"isArrayLike\");\n  En.exports = qu;\n});\n\n// ../node_modules/lodash/keys.js\nvar Me = l((Sg, An) => {\n  var Iu = gn(), Ru = Sn(), ju = On();\n  function Fu(e) {\n    return ju(e) ? Iu(e) : Ru(e);\n  }\n  r(Fu, \"keys\");\n  An.exports = Fu;\n});\n\n// ../node_modules/lodash/_baseForOwn.js\nvar _n = l((Og, Nn) => {\n  var Lu = Kr(), ku = Me();\n  function Cu(e, n) {\n    return e && Lu(e, n, ku);\n  }\n  r(Cu, \"baseForOwn\");\n  Nn.exports = Cu;\n});\n\n// ../node_modules/lodash/_listCacheClear.js\nvar qn = l((Ng, Dn) => {\n  function Uu() {\n    this.__data__ = [], this.size = 0;\n  }\n  r(Uu, \"listCacheClear\");\n  Dn.exports = Uu;\n});\n\n// ../node_modules/lodash/eq.js\nvar Pt = l((Dg, In) => {\n  function Mu(e, n) {\n    return e === n || e !== e && n !== n;\n  }\n  r(Mu, \"eq\");\n  In.exports = Mu;\n});\n\n// ../node_modules/lodash/_assocIndexOf.js\nvar Pe = l((Ig, Rn) => {\n  var Vu = Pt();\n  function Ku(e, n) {\n    for (var a = e.length; a--; )\n      if (Vu(e[a][0], n))\n        return a;\n    return -1;\n  }\n  r(Ku, \"assocIndexOf\");\n  Rn.exports = Ku;\n});\n\n// ../node_modules/lodash/_listCacheDelete.js\nvar Fn = l((jg, jn) => {\n  var Bu = Pe(), $u = Array.prototype, Gu = $u.splice;\n  function Yu(e) {\n    var n = this.__data__, a = Bu(n, e);\n    if (a < 0)\n      return !1;\n    var s = n.length - 1;\n    return a == s ? n.pop() : Gu.call(n, a, 1), --this.size, !0;\n  }\n  r(Yu, \"listCacheDelete\");\n  jn.exports = Yu;\n});\n\n// ../node_modules/lodash/_listCacheGet.js\nvar kn = l((Lg, Ln) => {\n  var Hu = Pe();\n  function zu(e) {\n    var n = this.__data__, a = Hu(n, e);\n    return a < 0 ? void 0 : n[a][1];\n  }\n  r(zu, \"listCacheGet\");\n  Ln.exports = zu;\n});\n\n// ../node_modules/lodash/_listCacheHas.js\nvar Un = l((Cg, Cn) => {\n  var Wu = Pe();\n  function Xu(e) {\n    return Wu(this.__data__, e) > -1;\n  }\n  r(Xu, \"listCacheHas\");\n  Cn.exports = Xu;\n});\n\n// ../node_modules/lodash/_listCacheSet.js\nvar Vn = l((Mg, Mn) => {\n  var Qu = Pe();\n  function Zu(e, n) {\n    var a = this.__data__, s = Qu(a, e);\n    return s < 0 ? (++this.size, a.push([e, n])) : a[s][1] = n, this;\n  }\n  r(Zu, \"listCacheSet\");\n  Mn.exports = Zu;\n});\n\n// ../node_modules/lodash/_ListCache.js\nvar Je = l((Kg, Kn) => {\n  var el = qn(), tl = Fn(), rl = kn(), nl = Un(), ol = Vn();\n  function se(e) {\n    var n = -1, a = e == null ? 0 : e.length;\n    for (this.clear(); ++n < a; ) {\n      var s = e[n];\n      this.set(s[0], s[1]);\n    }\n  }\n  r(se, \"ListCache\");\n  se.prototype.clear = el;\n  se.prototype.delete = tl;\n  se.prototype.get = rl;\n  se.prototype.has = nl;\n  se.prototype.set = ol;\n  Kn.exports = se;\n});\n\n// ../node_modules/lodash/_stackClear.js\nvar $n = l(($g, Bn) => {\n  var al = Je();\n  function il() {\n    this.__data__ = new al(), this.size = 0;\n  }\n  r(il, \"stackClear\");\n  Bn.exports = il;\n});\n\n// ../node_modules/lodash/_stackDelete.js\nvar Yn = l((Yg, Gn) => {\n  function sl(e) {\n    var n = this.__data__, a = n.delete(e);\n    return this.size = n.size, a;\n  }\n  r(sl, \"stackDelete\");\n  Gn.exports = sl;\n});\n\n// ../node_modules/lodash/_stackGet.js\nvar zn = l((zg, Hn) => {\n  function pl(e) {\n    return this.__data__.get(e);\n  }\n  r(pl, \"stackGet\");\n  Hn.exports = pl;\n});\n\n// ../node_modules/lodash/_stackHas.js\nvar Xn = l((Xg, Wn) => {\n  function cl(e) {\n    return this.__data__.has(e);\n  }\n  r(cl, \"stackHas\");\n  Wn.exports = cl;\n});\n\n// ../node_modules/lodash/_Map.js\nvar Ve = l((Zg, Qn) => {\n  var ul = H(), ll = L(), fl = ul(ll, \"Map\");\n  Qn.exports = fl;\n});\n\n// ../node_modules/lodash/_nativeCreate.js\nvar Se = l((eh, Zn) => {\n  var yl = H(), dl = yl(Object, \"create\");\n  Zn.exports = dl;\n});\n\n// ../node_modules/lodash/_hashClear.js\nvar ro = l((th, to) => {\n  var eo = Se();\n  function ml() {\n    this.__data__ = eo ? eo(null) : {}, this.size = 0;\n  }\n  r(ml, \"hashClear\");\n  to.exports = ml;\n});\n\n// ../node_modules/lodash/_hashDelete.js\nvar oo = l((nh, no) => {\n  function Tl(e) {\n    var n = this.has(e) && delete this.__data__[e];\n    return this.size -= n ? 1 : 0, n;\n  }\n  r(Tl, \"hashDelete\");\n  no.exports = Tl;\n});\n\n// ../node_modules/lodash/_hashGet.js\nvar io = l((ah, ao) => {\n  var gl = Se(), hl = \"__lodash_hash_undefined__\", xl = Object.prototype, bl = xl.hasOwnProperty;\n  function vl(e) {\n    var n = this.__data__;\n    if (gl) {\n      var a = n[e];\n      return a === hl ? void 0 : a;\n    }\n    return bl.call(n, e) ? n[e] : void 0;\n  }\n  r(vl, \"hashGet\");\n  ao.exports = vl;\n});\n\n// ../node_modules/lodash/_hashHas.js\nvar po = l((sh, so) => {\n  var wl = Se(), Pl = Object.prototype, Jl = Pl.hasOwnProperty;\n  function Sl(e) {\n    var n = this.__data__;\n    return wl ? n[e] !== void 0 : Jl.call(n, e);\n  }\n  r(Sl, \"hashHas\");\n  so.exports = Sl;\n});\n\n// ../node_modules/lodash/_hashSet.js\nvar uo = l((ch, co) => {\n  var El = Se(), Ol = \"__lodash_hash_undefined__\";\n  function Al(e, n) {\n    var a = this.__data__;\n    return this.size += this.has(e) ? 0 : 1, a[e] = El && n === void 0 ? Ol : n, this;\n  }\n  r(Al, \"hashSet\");\n  co.exports = Al;\n});\n\n// ../node_modules/lodash/_Hash.js\nvar fo = l((lh, lo) => {\n  var Nl = ro(), _l = oo(), Dl = io(), ql = po(), Il = uo();\n  function pe(e) {\n    var n = -1, a = e == null ? 0 : e.length;\n    for (this.clear(); ++n < a; ) {\n      var s = e[n];\n      this.set(s[0], s[1]);\n    }\n  }\n  r(pe, \"Hash\");\n  pe.prototype.clear = Nl;\n  pe.prototype.delete = _l;\n  pe.prototype.get = Dl;\n  pe.prototype.has = ql;\n  pe.prototype.set = Il;\n  lo.exports = pe;\n});\n\n// ../node_modules/lodash/_mapCacheClear.js\nvar To = l((yh, mo) => {\n  var yo = fo(), Rl = Je(), jl = Ve();\n  function Fl() {\n    this.size = 0, this.__data__ = {\n      hash: new yo(),\n      map: new (jl || Rl)(),\n      string: new yo()\n    };\n  }\n  r(Fl, \"mapCacheClear\");\n  mo.exports = Fl;\n});\n\n// ../node_modules/lodash/_isKeyable.js\nvar ho = l((mh, go) => {\n  function Ll(e) {\n    var n = typeof e;\n    return n == \"string\" || n == \"number\" || n == \"symbol\" || n == \"boolean\" ? e !== \"__proto__\" : e === null;\n  }\n  r(Ll, \"isKeyable\");\n  go.exports = Ll;\n});\n\n// ../node_modules/lodash/_getMapData.js\nvar Ee = l((gh, xo) => {\n  var kl = ho();\n  function Cl(e, n) {\n    var a = e.__data__;\n    return kl(n) ? a[typeof n == \"string\" ? \"string\" : \"hash\"] : a.map;\n  }\n  r(Cl, \"getMapData\");\n  xo.exports = Cl;\n});\n\n// ../node_modules/lodash/_mapCacheDelete.js\nvar vo = l((xh, bo) => {\n  var Ul = Ee();\n  function Ml(e) {\n    var n = Ul(this, e).delete(e);\n    return this.size -= n ? 1 : 0, n;\n  }\n  r(Ml, \"mapCacheDelete\");\n  bo.exports = Ml;\n});\n\n// ../node_modules/lodash/_mapCacheGet.js\nvar Po = l((vh, wo) => {\n  var Vl = Ee();\n  function Kl(e) {\n    return Vl(this, e).get(e);\n  }\n  r(Kl, \"mapCacheGet\");\n  wo.exports = Kl;\n});\n\n// ../node_modules/lodash/_mapCacheHas.js\nvar So = l((Ph, Jo) => {\n  var Bl = Ee();\n  function $l(e) {\n    return Bl(this, e).has(e);\n  }\n  r($l, \"mapCacheHas\");\n  Jo.exports = $l;\n});\n\n// ../node_modules/lodash/_mapCacheSet.js\nvar Oo = l((Sh, Eo) => {\n  var Gl = Ee();\n  function Yl(e, n) {\n    var a = Gl(this, e), s = a.size;\n    return a.set(e, n), this.size += a.size == s ? 0 : 1, this;\n  }\n  r(Yl, \"mapCacheSet\");\n  Eo.exports = Yl;\n});\n\n// ../node_modules/lodash/_MapCache.js\nvar Ke = l((Oh, Ao) => {\n  var Hl = To(), zl = vo(), Wl = Po(), Xl = So(), Ql = Oo();\n  function ce(e) {\n    var n = -1, a = e == null ? 0 : e.length;\n    for (this.clear(); ++n < a; ) {\n      var s = e[n];\n      this.set(s[0], s[1]);\n    }\n  }\n  r(ce, \"MapCache\");\n  ce.prototype.clear = Hl;\n  ce.prototype.delete = zl;\n  ce.prototype.get = Wl;\n  ce.prototype.has = Xl;\n  ce.prototype.set = Ql;\n  Ao.exports = ce;\n});\n\n// ../node_modules/lodash/_stackSet.js\nvar _o = l((Nh, No) => {\n  var Zl = Je(), ef = Ve(), tf = Ke(), rf = 200;\n  function nf(e, n) {\n    var a = this.__data__;\n    if (a instanceof Zl) {\n      var s = a.__data__;\n      if (!ef || s.length < rf - 1)\n        return s.push([e, n]), this.size = ++a.size, this;\n      a = this.__data__ = new tf(s);\n    }\n    return a.set(e, n), this.size = a.size, this;\n  }\n  r(nf, \"stackSet\");\n  No.exports = nf;\n});\n\n// ../node_modules/lodash/_Stack.js\nvar Jt = l((Dh, Do) => {\n  var of = Je(), af = $n(), sf = Yn(), pf = zn(), cf = Xn(), uf = _o();\n  function ue(e) {\n    var n = this.__data__ = new of(e);\n    this.size = n.size;\n  }\n  r(ue, \"Stack\");\n  ue.prototype.clear = af;\n  ue.prototype.delete = sf;\n  ue.prototype.get = pf;\n  ue.prototype.has = cf;\n  ue.prototype.set = uf;\n  Do.exports = ue;\n});\n\n// ../node_modules/lodash/_setCacheAdd.js\nvar Io = l((Ih, qo) => {\n  var lf = \"__lodash_hash_undefined__\";\n  function ff(e) {\n    return this.__data__.set(e, lf), this;\n  }\n  r(ff, \"setCacheAdd\");\n  qo.exports = ff;\n});\n\n// ../node_modules/lodash/_setCacheHas.js\nvar jo = l((jh, Ro) => {\n  function yf(e) {\n    return this.__data__.has(e);\n  }\n  r(yf, \"setCacheHas\");\n  Ro.exports = yf;\n});\n\n// ../node_modules/lodash/_SetCache.js\nvar Lo = l((Lh, Fo) => {\n  var df = Ke(), mf = Io(), Tf = jo();\n  function Be(e) {\n    var n = -1, a = e == null ? 0 : e.length;\n    for (this.__data__ = new df(); ++n < a; )\n      this.add(e[n]);\n  }\n  r(Be, \"SetCache\");\n  Be.prototype.add = Be.prototype.push = mf;\n  Be.prototype.has = Tf;\n  Fo.exports = Be;\n});\n\n// ../node_modules/lodash/_arraySome.js\nvar Co = l((Ch, ko) => {\n  function gf(e, n) {\n    for (var a = -1, s = e == null ? 0 : e.length; ++a < s; )\n      if (n(e[a], a, e))\n        return !0;\n    return !1;\n  }\n  r(gf, \"arraySome\");\n  ko.exports = gf;\n});\n\n// ../node_modules/lodash/_cacheHas.js\nvar Mo = l((Mh, Uo) => {\n  function hf(e, n) {\n    return e.has(n);\n  }\n  r(hf, \"cacheHas\");\n  Uo.exports = hf;\n});\n\n// ../node_modules/lodash/_equalArrays.js\nvar St = l((Kh, Vo) => {\n  var xf = Lo(), bf = Co(), vf = Mo(), wf = 1, Pf = 2;\n  function Jf(e, n, a, s, p, c) {\n    var y = a & wf, d = e.length, m = n.length;\n    if (d != m && !(y && m > d))\n      return !1;\n    var g = c.get(e), b = c.get(n);\n    if (g && b)\n      return g == n && b == e;\n    var A = -1, J = !0, v = a & Pf ? new xf() : void 0;\n    for (c.set(e, n), c.set(n, e); ++A < d; ) {\n      var N = e[A], q = n[A];\n      if (s)\n        var R = y ? s(q, N, A, n, e, c) : s(N, q, A, e, n, c);\n      if (R !== void 0) {\n        if (R)\n          continue;\n        J = !1;\n        break;\n      }\n      if (v) {\n        if (!bf(n, function(k, C) {\n          if (!vf(v, C) && (N === k || p(N, k, a, s, c)))\n            return v.push(C);\n        })) {\n          J = !1;\n          break;\n        }\n      } else if (!(N === q || p(N, q, a, s, c))) {\n        J = !1;\n        break;\n      }\n    }\n    return c.delete(e), c.delete(n), J;\n  }\n  r(Jf, \"equalArrays\");\n  Vo.exports = Jf;\n});\n\n// ../node_modules/lodash/_Uint8Array.js\nvar Bo = l(($h, Ko) => {\n  var Sf = L(), Ef = Sf.Uint8Array;\n  Ko.exports = Ef;\n});\n\n// ../node_modules/lodash/_mapToArray.js\nvar Go = l((Gh, $o) => {\n  function Of(e) {\n    var n = -1, a = Array(e.size);\n    return e.forEach(function(s, p) {\n      a[++n] = [p, s];\n    }), a;\n  }\n  r(Of, \"mapToArray\");\n  $o.exports = Of;\n});\n\n// ../node_modules/lodash/_setToArray.js\nvar Ho = l((Hh, Yo) => {\n  function Af(e) {\n    var n = -1, a = Array(e.size);\n    return e.forEach(function(s) {\n      a[++n] = s;\n    }), a;\n  }\n  r(Af, \"setToArray\");\n  Yo.exports = Af;\n});\n\n// ../node_modules/lodash/_equalByTag.js\nvar Zo = l((Wh, Qo) => {\n  var zo = he(), Wo = Bo(), Nf = Pt(), _f = St(), Df = Go(), qf = Ho(), If = 1, Rf = 2, jf = \"[object Boolean]\", Ff = \"[object Date]\", Lf = \"\\\n[object Error]\", kf = \"[object Map]\", Cf = \"[object Number]\", Uf = \"[object RegExp]\", Mf = \"[object Set]\", Vf = \"[object String]\", Kf = \"[ob\\\nject Symbol]\", Bf = \"[object ArrayBuffer]\", $f = \"[object DataView]\", Xo = zo ? zo.prototype : void 0, Et = Xo ? Xo.valueOf : void 0;\n  function Gf(e, n, a, s, p, c, y) {\n    switch (a) {\n      case $f:\n        if (e.byteLength != n.byteLength || e.byteOffset != n.byteOffset)\n          return !1;\n        e = e.buffer, n = n.buffer;\n      case Bf:\n        return !(e.byteLength != n.byteLength || !c(new Wo(e), new Wo(n)));\n      case jf:\n      case Ff:\n      case Cf:\n        return Nf(+e, +n);\n      case Lf:\n        return e.name == n.name && e.message == n.message;\n      case Uf:\n      case Vf:\n        return e == n + \"\";\n      case kf:\n        var d = Df;\n      case Mf:\n        var m = s & If;\n        if (d || (d = qf), e.size != n.size && !m)\n          return !1;\n        var g = y.get(e);\n        if (g)\n          return g == n;\n        s |= Rf, y.set(e, n);\n        var b = _f(d(e), d(n), s, p, c, y);\n        return y.delete(e), b;\n      case Kf:\n        if (Et)\n          return Et.call(e) == Et.call(n);\n    }\n    return !1;\n  }\n  r(Gf, \"equalByTag\");\n  Qo.exports = Gf;\n});\n\n// ../node_modules/lodash/_arrayPush.js\nvar ta = l((Qh, ea) => {\n  function Yf(e, n) {\n    for (var a = -1, s = n.length, p = e.length; ++a < s; )\n      e[p + a] = n[a];\n    return e;\n  }\n  r(Yf, \"arrayPush\");\n  ea.exports = Yf;\n});\n\n// ../node_modules/lodash/_baseGetAllKeys.js\nvar na = l((ex, ra) => {\n  var Hf = ta(), zf = M();\n  function Wf(e, n, a) {\n    var s = n(e);\n    return zf(e) ? s : Hf(s, a(e));\n  }\n  r(Wf, \"baseGetAllKeys\");\n  ra.exports = Wf;\n});\n\n// ../node_modules/lodash/_arrayFilter.js\nvar aa = l((rx, oa) => {\n  function Xf(e, n) {\n    for (var a = -1, s = e == null ? 0 : e.length, p = 0, c = []; ++a < s; ) {\n      var y = e[a];\n      n(y, a, e) && (c[p++] = y);\n    }\n    return c;\n  }\n  r(Xf, \"arrayFilter\");\n  oa.exports = Xf;\n});\n\n// ../node_modules/lodash/stubArray.js\nvar sa = l((ox, ia) => {\n  function Qf() {\n    return [];\n  }\n  r(Qf, \"stubArray\");\n  ia.exports = Qf;\n});\n\n// ../node_modules/lodash/_getSymbols.js\nvar ua = l((ix, ca) => {\n  var Zf = aa(), ey = sa(), ty = Object.prototype, ry = ty.propertyIsEnumerable, pa = Object.getOwnPropertySymbols, ny = pa ? function(e) {\n    return e == null ? [] : (e = Object(e), Zf(pa(e), function(n) {\n      return ry.call(e, n);\n    }));\n  } : ey;\n  ca.exports = ny;\n});\n\n// ../node_modules/lodash/_getAllKeys.js\nvar fa = l((sx, la) => {\n  var oy = na(), ay = ua(), iy = Me();\n  function sy(e) {\n    return oy(e, iy, ay);\n  }\n  r(sy, \"getAllKeys\");\n  la.exports = sy;\n});\n\n// ../node_modules/lodash/_equalObjects.js\nvar ma = l((cx, da) => {\n  var ya = fa(), py = 1, cy = Object.prototype, uy = cy.hasOwnProperty;\n  function ly(e, n, a, s, p, c) {\n    var y = a & py, d = ya(e), m = d.length, g = ya(n), b = g.length;\n    if (m != b && !y)\n      return !1;\n    for (var A = m; A--; ) {\n      var J = d[A];\n      if (!(y ? J in n : uy.call(n, J)))\n        return !1;\n    }\n    var v = c.get(e), N = c.get(n);\n    if (v && N)\n      return v == n && N == e;\n    var q = !0;\n    c.set(e, n), c.set(n, e);\n    for (var R = y; ++A < m; ) {\n      J = d[A];\n      var k = e[J], C = n[J];\n      if (s)\n        var Q = y ? s(C, k, J, n, e, c) : s(k, C, J, e, n, c);\n      if (!(Q === void 0 ? k === C || p(k, C, a, s, c) : Q)) {\n        q = !1;\n        break;\n      }\n      R || (R = J == \"constructor\");\n    }\n    if (q && !R) {\n      var w = e.constructor, K = n.constructor;\n      w != K && \"constructor\" in e && \"constructor\" in n && !(typeof w == \"function\" && w instanceof w && typeof K == \"function\" && K instanceof\n      K) && (q = !1);\n    }\n    return c.delete(e), c.delete(n), q;\n  }\n  r(ly, \"equalObjects\");\n  da.exports = ly;\n});\n\n// ../node_modules/lodash/_DataView.js\nvar ga = l((lx, Ta) => {\n  var fy = H(), yy = L(), dy = fy(yy, \"DataView\");\n  Ta.exports = dy;\n});\n\n// ../node_modules/lodash/_Promise.js\nvar xa = l((fx, ha) => {\n  var my = H(), Ty = L(), gy = my(Ty, \"Promise\");\n  ha.exports = gy;\n});\n\n// ../node_modules/lodash/_Set.js\nvar va = l((yx, ba) => {\n  var hy = H(), xy = L(), by = hy(xy, \"Set\");\n  ba.exports = by;\n});\n\n// ../node_modules/lodash/_WeakMap.js\nvar Pa = l((dx, wa) => {\n  var vy = H(), wy = L(), Py = vy(wy, \"WeakMap\");\n  wa.exports = Py;\n});\n\n// ../node_modules/lodash/_getTag.js\nvar Da = l((mx, _a) => {\n  var Ot = ga(), At = Ve(), Nt = xa(), _t = va(), Dt = Pa(), Na = ne(), le = gt(), Ja = \"[object Map]\", Jy = \"[object Object]\", Sa = \"[objec\\\nt Promise]\", Ea = \"[object Set]\", Oa = \"[object WeakMap]\", Aa = \"[object DataView]\", Sy = le(Ot), Ey = le(At), Oy = le(Nt), Ay = le(_t), Ny = le(\n  Dt), X = Na;\n  (Ot && X(new Ot(new ArrayBuffer(1))) != Aa || At && X(new At()) != Ja || Nt && X(Nt.resolve()) != Sa || _t && X(new _t()) != Ea || Dt && X(\n  new Dt()) != Oa) && (X = /* @__PURE__ */ r(function(e) {\n    var n = Na(e), a = n == Jy ? e.constructor : void 0, s = a ? le(a) : \"\";\n    if (s)\n      switch (s) {\n        case Sy:\n          return Aa;\n        case Ey:\n          return Ja;\n        case Oy:\n          return Sa;\n        case Ay:\n          return Ea;\n        case Ny:\n          return Oa;\n      }\n    return n;\n  }, \"getTag\"));\n  _a.exports = X;\n});\n\n// ../node_modules/lodash/_baseIsEqualDeep.js\nvar Ca = l((gx, ka) => {\n  var qt = Jt(), _y = St(), Dy = Zo(), qy = ma(), qa = Da(), Ia = M(), Ra = xt(), Iy = wt(), Ry = 1, ja = \"[object Arguments]\", Fa = \"[objec\\\nt Array]\", $e = \"[object Object]\", jy = Object.prototype, La = jy.hasOwnProperty;\n  function Fy(e, n, a, s, p, c) {\n    var y = Ia(e), d = Ia(n), m = y ? Fa : qa(e), g = d ? Fa : qa(n);\n    m = m == ja ? $e : m, g = g == ja ? $e : g;\n    var b = m == $e, A = g == $e, J = m == g;\n    if (J && Ra(e)) {\n      if (!Ra(n))\n        return !1;\n      y = !0, b = !1;\n    }\n    if (J && !b)\n      return c || (c = new qt()), y || Iy(e) ? _y(e, n, a, s, p, c) : Dy(e, n, m, a, s, p, c);\n    if (!(a & Ry)) {\n      var v = b && La.call(e, \"__wrapped__\"), N = A && La.call(n, \"__wrapped__\");\n      if (v || N) {\n        var q = v ? e.value() : e, R = N ? n.value() : n;\n        return c || (c = new qt()), p(q, R, a, s, c);\n      }\n    }\n    return J ? (c || (c = new qt()), qy(e, n, a, s, p, c)) : !1;\n  }\n  r(Fy, \"baseIsEqualDeep\");\n  ka.exports = Fy;\n});\n\n// ../node_modules/lodash/_baseIsEqual.js\nvar It = l((xx, Va) => {\n  var Ly = Ca(), Ua = oe();\n  function Ma(e, n, a, s, p) {\n    return e === n ? !0 : e == null || n == null || !Ua(e) && !Ua(n) ? e !== e && n !== n : Ly(e, n, a, s, Ma, p);\n  }\n  r(Ma, \"baseIsEqual\");\n  Va.exports = Ma;\n});\n\n// ../node_modules/lodash/_baseIsMatch.js\nvar Ba = l((vx, Ka) => {\n  var ky = Jt(), Cy = It(), Uy = 1, My = 2;\n  function Vy(e, n, a, s) {\n    var p = a.length, c = p, y = !s;\n    if (e == null)\n      return !c;\n    for (e = Object(e); p--; ) {\n      var d = a[p];\n      if (y && d[2] ? d[1] !== e[d[0]] : !(d[0] in e))\n        return !1;\n    }\n    for (; ++p < c; ) {\n      d = a[p];\n      var m = d[0], g = e[m], b = d[1];\n      if (y && d[2]) {\n        if (g === void 0 && !(m in e))\n          return !1;\n      } else {\n        var A = new ky();\n        if (s)\n          var J = s(g, b, m, e, n, A);\n        if (!(J === void 0 ? Cy(b, g, Uy | My, s, A) : J))\n          return !1;\n      }\n    }\n    return !0;\n  }\n  r(Vy, \"baseIsMatch\");\n  Ka.exports = Vy;\n});\n\n// ../node_modules/lodash/_isStrictComparable.js\nvar Rt = l((Px, $a) => {\n  var Ky = Ce();\n  function By(e) {\n    return e === e && !Ky(e);\n  }\n  r(By, \"isStrictComparable\");\n  $a.exports = By;\n});\n\n// ../node_modules/lodash/_getMatchData.js\nvar Ya = l((Sx, Ga) => {\n  var $y = Rt(), Gy = Me();\n  function Yy(e) {\n    for (var n = Gy(e), a = n.length; a--; ) {\n      var s = n[a], p = e[s];\n      n[a] = [s, p, $y(p)];\n    }\n    return n;\n  }\n  r(Yy, \"getMatchData\");\n  Ga.exports = Yy;\n});\n\n// ../node_modules/lodash/_matchesStrictComparable.js\nvar jt = l((Ox, Ha) => {\n  function Hy(e, n) {\n    return function(a) {\n      return a == null ? !1 : a[e] === n && (n !== void 0 || e in Object(a));\n    };\n  }\n  r(Hy, \"matchesStrictComparable\");\n  Ha.exports = Hy;\n});\n\n// ../node_modules/lodash/_baseMatches.js\nvar Wa = l((Nx, za) => {\n  var zy = Ba(), Wy = Ya(), Xy = jt();\n  function Qy(e) {\n    var n = Wy(e);\n    return n.length == 1 && n[0][2] ? Xy(n[0][0], n[0][1]) : function(a) {\n      return a === e || zy(a, e, n);\n    };\n  }\n  r(Qy, \"baseMatches\");\n  za.exports = Qy;\n});\n\n// ../node_modules/lodash/isSymbol.js\nvar Ge = l((Dx, Xa) => {\n  var Zy = ne(), ed = oe(), td = \"[object Symbol]\";\n  function rd(e) {\n    return typeof e == \"symbol\" || ed(e) && Zy(e) == td;\n  }\n  r(rd, \"isSymbol\");\n  Xa.exports = rd;\n});\n\n// ../node_modules/lodash/_isKey.js\nvar Ye = l((Ix, Qa) => {\n  var nd = M(), od = Ge(), ad = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/, id = /^\\w*$/;\n  function sd(e, n) {\n    if (nd(e))\n      return !1;\n    var a = typeof e;\n    return a == \"number\" || a == \"symbol\" || a == \"boolean\" || e == null || od(e) ? !0 : id.test(e) || !ad.test(e) || n != null && e in Object(\n    n);\n  }\n  r(sd, \"isKey\");\n  Qa.exports = sd;\n});\n\n// ../node_modules/lodash/memoize.js\nvar ti = l((jx, ei) => {\n  var Za = Ke(), pd = \"Expected a function\";\n  function Ft(e, n) {\n    if (typeof e != \"function\" || n != null && typeof n != \"function\")\n      throw new TypeError(pd);\n    var a = /* @__PURE__ */ r(function() {\n      var s = arguments, p = n ? n.apply(this, s) : s[0], c = a.cache;\n      if (c.has(p))\n        return c.get(p);\n      var y = e.apply(this, s);\n      return a.cache = c.set(p, y) || c, y;\n    }, \"memoized\");\n    return a.cache = new (Ft.Cache || Za)(), a;\n  }\n  r(Ft, \"memoize\");\n  Ft.Cache = Za;\n  ei.exports = Ft;\n});\n\n// ../node_modules/lodash/_memoizeCapped.js\nvar ni = l((Lx, ri) => {\n  var cd = ti(), ud = 500;\n  function ld(e) {\n    var n = cd(e, function(s) {\n      return a.size === ud && a.clear(), s;\n    }), a = n.cache;\n    return n;\n  }\n  r(ld, \"memoizeCapped\");\n  ri.exports = ld;\n});\n\n// ../node_modules/lodash/_stringToPath.js\nvar ai = l((Cx, oi) => {\n  var fd = ni(), yd = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g, dd = /\\\\(\\\\)?/g, md = fd(\n  function(e) {\n    var n = [];\n    return e.charCodeAt(0) === 46 && n.push(\"\"), e.replace(yd, function(a, s, p, c) {\n      n.push(p ? c.replace(dd, \"$1\") : s || a);\n    }), n;\n  });\n  oi.exports = md;\n});\n\n// ../node_modules/lodash/_arrayMap.js\nvar si = l((Ux, ii) => {\n  function Td(e, n) {\n    for (var a = -1, s = e == null ? 0 : e.length, p = Array(s); ++a < s; )\n      p[a] = n(e[a], a, e);\n    return p;\n  }\n  r(Td, \"arrayMap\");\n  ii.exports = Td;\n});\n\n// ../node_modules/lodash/_baseToString.js\nvar yi = l((Vx, fi) => {\n  var pi = he(), gd = si(), hd = M(), xd = Ge(), bd = 1 / 0, ci = pi ? pi.prototype : void 0, ui = ci ? ci.toString : void 0;\n  function li(e) {\n    if (typeof e == \"string\")\n      return e;\n    if (hd(e))\n      return gd(e, li) + \"\";\n    if (xd(e))\n      return ui ? ui.call(e) : \"\";\n    var n = e + \"\";\n    return n == \"0\" && 1 / e == -bd ? \"-0\" : n;\n  }\n  r(li, \"baseToString\");\n  fi.exports = li;\n});\n\n// ../node_modules/lodash/toString.js\nvar mi = l((Bx, di) => {\n  var vd = yi();\n  function wd(e) {\n    return e == null ? \"\" : vd(e);\n  }\n  r(wd, \"toString\");\n  di.exports = wd;\n});\n\n// ../node_modules/lodash/_castPath.js\nvar Lt = l((Gx, Ti) => {\n  var Pd = M(), Jd = Ye(), Sd = ai(), Ed = mi();\n  function Od(e, n) {\n    return Pd(e) ? e : Jd(e, n) ? [e] : Sd(Ed(e));\n  }\n  r(Od, \"castPath\");\n  Ti.exports = Od;\n});\n\n// ../node_modules/lodash/_toKey.js\nvar Oe = l((Hx, gi) => {\n  var Ad = Ge(), Nd = 1 / 0;\n  function _d(e) {\n    if (typeof e == \"string\" || Ad(e))\n      return e;\n    var n = e + \"\";\n    return n == \"0\" && 1 / e == -Nd ? \"-0\" : n;\n  }\n  r(_d, \"toKey\");\n  gi.exports = _d;\n});\n\n// ../node_modules/lodash/_baseGet.js\nvar kt = l((Wx, hi) => {\n  var Dd = Lt(), qd = Oe();\n  function Id(e, n) {\n    n = Dd(n, e);\n    for (var a = 0, s = n.length; e != null && a < s; )\n      e = e[qd(n[a++])];\n    return a && a == s ? e : void 0;\n  }\n  r(Id, \"baseGet\");\n  hi.exports = Id;\n});\n\n// ../node_modules/lodash/get.js\nvar bi = l((Qx, xi) => {\n  var Rd = kt();\n  function jd(e, n, a) {\n    var s = e == null ? void 0 : Rd(e, n);\n    return s === void 0 ? a : s;\n  }\n  r(jd, \"get\");\n  xi.exports = jd;\n});\n\n// ../node_modules/lodash/_baseHasIn.js\nvar wi = l((eb, vi) => {\n  function Fd(e, n) {\n    return e != null && n in Object(e);\n  }\n  r(Fd, \"baseHasIn\");\n  vi.exports = Fd;\n});\n\n// ../node_modules/lodash/_hasPath.js\nvar Ji = l((rb, Pi) => {\n  var Ld = Lt(), kd = ht(), Cd = M(), Ud = bt(), Md = Ue(), Vd = Oe();\n  function Kd(e, n, a) {\n    n = Ld(n, e);\n    for (var s = -1, p = n.length, c = !1; ++s < p; ) {\n      var y = Vd(n[s]);\n      if (!(c = e != null && a(e, y)))\n        break;\n      e = e[y];\n    }\n    return c || ++s != p ? c : (p = e == null ? 0 : e.length, !!p && Md(p) && Ud(y, p) && (Cd(e) || kd(e)));\n  }\n  r(Kd, \"hasPath\");\n  Pi.exports = Kd;\n});\n\n// ../node_modules/lodash/hasIn.js\nvar Ei = l((ob, Si) => {\n  var Bd = wi(), $d = Ji();\n  function Gd(e, n) {\n    return e != null && $d(e, n, Bd);\n  }\n  r(Gd, \"hasIn\");\n  Si.exports = Gd;\n});\n\n// ../node_modules/lodash/_baseMatchesProperty.js\nvar Ai = l((ib, Oi) => {\n  var Yd = It(), Hd = bi(), zd = Ei(), Wd = Ye(), Xd = Rt(), Qd = jt(), Zd = Oe(), em = 1, tm = 2;\n  function rm(e, n) {\n    return Wd(e) && Xd(n) ? Qd(Zd(e), n) : function(a) {\n      var s = Hd(a, e);\n      return s === void 0 && s === n ? zd(a, e) : Yd(n, s, em | tm);\n    };\n  }\n  r(rm, \"baseMatchesProperty\");\n  Oi.exports = rm;\n});\n\n// ../node_modules/lodash/identity.js\nvar _i = l((pb, Ni) => {\n  function nm(e) {\n    return e;\n  }\n  r(nm, \"identity\");\n  Ni.exports = nm;\n});\n\n// ../node_modules/lodash/_baseProperty.js\nvar qi = l((ub, Di) => {\n  function om(e) {\n    return function(n) {\n      return n?.[e];\n    };\n  }\n  r(om, \"baseProperty\");\n  Di.exports = om;\n});\n\n// ../node_modules/lodash/_basePropertyDeep.js\nvar Ri = l((fb, Ii) => {\n  var am = kt();\n  function im(e) {\n    return function(n) {\n      return am(n, e);\n    };\n  }\n  r(im, \"basePropertyDeep\");\n  Ii.exports = im;\n});\n\n// ../node_modules/lodash/property.js\nvar Fi = l((db, ji) => {\n  var sm = qi(), pm = Ri(), cm = Ye(), um = Oe();\n  function lm(e) {\n    return cm(e) ? sm(um(e)) : pm(e);\n  }\n  r(lm, \"property\");\n  ji.exports = lm;\n});\n\n// ../node_modules/lodash/_baseIteratee.js\nvar ki = l((Tb, Li) => {\n  var fm = Wa(), ym = Ai(), dm = _i(), mm = M(), Tm = Fi();\n  function gm(e) {\n    return typeof e == \"function\" ? e : e == null ? dm : typeof e == \"object\" ? mm(e) ? ym(e[0], e[1]) : fm(e) : Tm(e);\n  }\n  r(gm, \"baseIteratee\");\n  Li.exports = gm;\n});\n\n// ../node_modules/lodash/mapValues.js\nvar Ui = l((hb, Ci) => {\n  var hm = Cr(), xm = _n(), bm = ki();\n  function vm(e, n) {\n    var a = {};\n    return n = bm(n, 3), xm(e, function(s, p, c) {\n      hm(a, p, n(s, p, c));\n    }), a;\n  }\n  r(vm, \"mapValues\");\n  Ci.exports = vm;\n});\n\n// ../node_modules/jsdoc-type-pratt-parser/dist/index.js\nvar Qi = l((Ze, Xi) => {\n  (function(e, n) {\n    typeof Ze == \"object\" && typeof Xi < \"u\" ? n(Ze) : typeof define == \"function\" && define.amd ? define([\"exports\"], n) : (e = typeof globalThis <\n    \"u\" ? globalThis : e || self, n(e.jtpp = {}));\n  })(Ze, function(e) {\n    \"use strict\";\n    function n(t) {\n      return t.text !== void 0 && t.text !== \"\" ? `'${t.type}' with value '${t.text}'` : `'${t.type}'`;\n    }\n    r(n, \"tokenToString\");\n    let Re = class Re extends Error {\n      constructor(o) {\n        super(`No parslet found for token: ${n(o)}`), this.token = o, Object.setPrototypeOf(this, Re.prototype);\n      }\n      getToken() {\n        return this.token;\n      }\n    };\n    r(Re, \"NoParsletFoundError\");\n    let a = Re, je = class je extends Error {\n      constructor(o) {\n        super(`The parsing ended early. The next token was: ${n(o)}`), this.token = o, Object.setPrototypeOf(this, je.prototype);\n      }\n      getToken() {\n        return this.token;\n      }\n    };\n    r(je, \"EarlyEndOfParseError\");\n    let s = je, Fe = class Fe extends Error {\n      constructor(o, i) {\n        let u = `Unexpected type: '${o.type}'.`;\n        i !== void 0 && (u += ` Message: ${i}`), super(u), Object.setPrototypeOf(this, Fe.prototype);\n      }\n    };\n    r(Fe, \"UnexpectedTypeError\");\n    let p = Fe;\n    function c(t) {\n      return (o) => o.startsWith(t) ? { type: t, text: t } : null;\n    }\n    r(c, \"makePunctuationRule\");\n    function y(t) {\n      let o = 0, i, u = t[0], f = !1;\n      if (u !== \"'\" && u !== '\"')\n        return null;\n      for (; o < t.length; ) {\n        if (o++, i = t[o], !f && i === u) {\n          o++;\n          break;\n        }\n        f = !f && i === \"\\\\\";\n      }\n      if (i !== u)\n        throw new Error(\"Unterminated String\");\n      return t.slice(0, o);\n    }\n    r(y, \"getQuoted\");\n    let d = new RegExp(\"[$_\\\\p{ID_Start}]|\\\\\\\\u\\\\p{Hex_Digit}{4}|\\\\\\\\u\\\\{0*(?:\\\\p{Hex_Digit}{1,5}|10\\\\p{Hex_Digit}{4})\\\\}\", \"u\"), m = new RegExp(\n    \"[$\\\\-\\\\p{ID_Continue}\\\\u200C\\\\u200D]|\\\\\\\\u\\\\p{Hex_Digit}{4}|\\\\\\\\u\\\\{0*(?:\\\\p{Hex_Digit}{1,5}|10\\\\p{Hex_Digit}{4})\\\\}\", \"u\");\n    function g(t) {\n      let o = t[0];\n      if (!d.test(o))\n        return null;\n      let i = 1;\n      do {\n        if (o = t[i], !m.test(o))\n          break;\n        i++;\n      } while (i < t.length);\n      return t.slice(0, i);\n    }\n    r(g, \"getIdentifier\");\n    let b = /^(NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity))/;\n    function A(t) {\n      var o, i;\n      return (i = (o = b.exec(t)) === null || o === void 0 ? void 0 : o[0]) !== null && i !== void 0 ? i : null;\n    }\n    r(A, \"getNumber\");\n    let J = /* @__PURE__ */ r((t) => {\n      let o = g(t);\n      return o == null ? null : {\n        type: \"Identifier\",\n        text: o\n      };\n    }, \"identifierRule\");\n    function v(t) {\n      return (o) => {\n        if (!o.startsWith(t))\n          return null;\n        let i = o[t.length];\n        return i !== void 0 && m.test(i) ? null : {\n          type: t,\n          text: t\n        };\n      };\n    }\n    r(v, \"makeKeyWordRule\");\n    let N = /* @__PURE__ */ r((t) => {\n      let o = y(t);\n      return o == null ? null : {\n        type: \"StringValue\",\n        text: o\n      };\n    }, \"stringValueRule\"), q = /* @__PURE__ */ r((t) => t.length > 0 ? null : {\n      type: \"EOF\",\n      text: \"\"\n    }, \"eofRule\"), R = /* @__PURE__ */ r((t) => {\n      let o = A(t);\n      return o === null ? null : {\n        type: \"Number\",\n        text: o\n      };\n    }, \"numberRule\"), k = [\n      q,\n      c(\"=>\"),\n      c(\"(\"),\n      c(\")\"),\n      c(\"{\"),\n      c(\"}\"),\n      c(\"[\"),\n      c(\"]\"),\n      c(\"|\"),\n      c(\"&\"),\n      c(\"<\"),\n      c(\">\"),\n      c(\",\"),\n      c(\";\"),\n      c(\"*\"),\n      c(\"?\"),\n      c(\"!\"),\n      c(\"=\"),\n      c(\":\"),\n      c(\"...\"),\n      c(\".\"),\n      c(\"#\"),\n      c(\"~\"),\n      c(\"/\"),\n      c(\"@\"),\n      v(\"undefined\"),\n      v(\"null\"),\n      v(\"function\"),\n      v(\"this\"),\n      v(\"new\"),\n      v(\"module\"),\n      v(\"event\"),\n      v(\"external\"),\n      v(\"typeof\"),\n      v(\"keyof\"),\n      v(\"readonly\"),\n      v(\"import\"),\n      v(\"is\"),\n      v(\"in\"),\n      R,\n      J,\n      N\n    ], C = /^\\s*\\n\\s*/, ee = class ee {\n      static create(o) {\n        let i = this.read(o);\n        o = i.text;\n        let u = this.read(o);\n        return o = u.text, new ee(o, void 0, i.token, u.token);\n      }\n      constructor(o, i, u, f) {\n        this.text = \"\", this.text = o, this.previous = i, this.current = u, this.next = f;\n      }\n      static read(o, i = !1) {\n        i = i || C.test(o), o = o.trim();\n        for (let u of k) {\n          let f = u(o);\n          if (f !== null) {\n            let T = Object.assign(Object.assign({}, f), { startOfLine: i });\n            return o = o.slice(T.text.length), { text: o, token: T };\n          }\n        }\n        throw new Error(\"Unexpected Token \" + o);\n      }\n      advance() {\n        let o = ee.read(this.text);\n        return new ee(o.text, this.current, this.next, o.token);\n      }\n    };\n    r(ee, \"Lexer\");\n    let Q = ee;\n    function w(t) {\n      if (t === void 0)\n        throw new Error(\"Unexpected undefined\");\n      if (t.type === \"JsdocTypeKeyValue\" || t.type === \"JsdocTypeParameterList\" || t.type === \"JsdocTypeProperty\" || t.type === \"JsdocTypeRe\\\nadonlyProperty\" || t.type === \"JsdocTypeObjectField\" || t.type === \"JsdocTypeJsdocObjectField\" || t.type === \"JsdocTypeIndexSignature\" || t.\n      type === \"JsdocTypeMappedType\")\n        throw new p(t);\n      return t;\n    }\n    r(w, \"assertRootResult\");\n    function K(t) {\n      return t.type === \"JsdocTypeKeyValue\" ? Ae(t) : w(t);\n    }\n    r(K, \"assertPlainKeyValueOrRootResult\");\n    function Ts(t) {\n      return t.type === \"JsdocTypeName\" ? t : Ae(t);\n    }\n    r(Ts, \"assertPlainKeyValueOrNameResult\");\n    function Ae(t) {\n      if (t.type !== \"JsdocTypeKeyValue\")\n        throw new p(t);\n      return t;\n    }\n    r(Ae, \"assertPlainKeyValueResult\");\n    function gs(t) {\n      var o;\n      if (t.type === \"JsdocTypeVariadic\") {\n        if (((o = t.element) === null || o === void 0 ? void 0 : o.type) === \"JsdocTypeName\")\n          return t;\n        throw new p(t);\n      }\n      if (t.type !== \"JsdocTypeNumber\" && t.type !== \"JsdocTypeName\")\n        throw new p(t);\n      return t;\n    }\n    r(gs, \"assertNumberOrVariadicNameResult\");\n    function tt(t) {\n      return t.type === \"JsdocTypeIndexSignature\" || t.type === \"JsdocTypeMappedType\";\n    }\n    r(tt, \"isSquaredProperty\");\n    var h;\n    (function(t) {\n      t[t.ALL = 0] = \"ALL\", t[t.PARAMETER_LIST = 1] = \"PARAMETER_LIST\", t[t.OBJECT = 2] = \"OBJECT\", t[t.KEY_VALUE = 3] = \"KEY_VALUE\", t[t.UNION =\n      4] = \"UNION\", t[t.INTERSECTION = 5] = \"INTERSECTION\", t[t.PREFIX = 6] = \"PREFIX\", t[t.INFIX = 7] = \"INFIX\", t[t.TUPLE = 8] = \"TUPLE\", t[t.\n      SYMBOL = 9] = \"SYMBOL\", t[t.OPTIONAL = 10] = \"OPTIONAL\", t[t.NULLABLE = 11] = \"NULLABLE\", t[t.KEY_OF_TYPE_OF = 12] = \"KEY_OF_TYPE_OF\",\n      t[t.FUNCTION = 13] = \"FUNCTION\", t[t.ARROW = 14] = \"ARROW\", t[t.ARRAY_BRACKETS = 15] = \"ARRAY_BRACKETS\", t[t.GENERIC = 16] = \"GENERIC\",\n      t[t.NAME_PATH = 17] = \"NAME_PATH\", t[t.PARENTHESIS = 18] = \"PARENTHESIS\", t[t.SPECIAL_TYPES = 19] = \"SPECIAL_TYPES\";\n    })(h || (h = {}));\n    let ft = class ft {\n      constructor(o, i, u) {\n        this.grammar = o, typeof i == \"string\" ? this._lexer = Q.create(i) : this._lexer = i, this.baseParser = u;\n      }\n      get lexer() {\n        return this._lexer;\n      }\n      /**\n       * Parses a given string and throws an error if the parse ended before the end of the string.\n       */\n      parse() {\n        let o = this.parseType(h.ALL);\n        if (this.lexer.current.type !== \"EOF\")\n          throw new s(this.lexer.current);\n        return o;\n      }\n      /**\n       * Parses with the current lexer and asserts that the result is a {@link RootResult}.\n       */\n      parseType(o) {\n        return w(this.parseIntermediateType(o));\n      }\n      /**\n       * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues\n       * to parse the state in the infix step.\n       */\n      parseIntermediateType(o) {\n        let i = this.tryParslets(null, o);\n        if (i === null)\n          throw new a(this.lexer.current);\n        return this.parseInfixIntermediateType(i, o);\n      }\n      /**\n       * In the infix parsing step the parser continues to parse the current state with all parslets until none returns\n       * a result.\n       */\n      parseInfixIntermediateType(o, i) {\n        let u = this.tryParslets(o, i);\n        for (; u !== null; )\n          o = u, u = this.tryParslets(o, i);\n        return o;\n      }\n      /**\n       * Tries to parse the current state with all parslets in the grammar and returns the first non null result.\n       */\n      tryParslets(o, i) {\n        for (let u of this.grammar) {\n          let f = u(this, i, o);\n          if (f !== null)\n            return f;\n        }\n        return null;\n      }\n      /**\n       * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was\n       * advanced.\n       */\n      consume(o) {\n        return Array.isArray(o) || (o = [o]), o.includes(this.lexer.current.type) ? (this._lexer = this.lexer.advance(), !0) : !1;\n      }\n      acceptLexerState(o) {\n        this._lexer = o.lexer;\n      }\n    };\n    r(ft, \"Parser\");\n    let B = ft;\n    function Wt(t) {\n      return t === \"EOF\" || t === \"|\" || t === \",\" || t === \")\" || t === \">\";\n    }\n    r(Wt, \"isQuestionMarkUnknownType\");\n    let rt = /* @__PURE__ */ r((t, o, i) => {\n      let u = t.lexer.current.type, f = t.lexer.next.type;\n      return i == null && u === \"?\" && !Wt(f) || i != null && u === \"?\" ? (t.consume(\"?\"), i == null ? {\n        type: \"JsdocTypeNullable\",\n        element: t.parseType(h.NULLABLE),\n        meta: {\n          position: \"prefix\"\n        }\n      } : {\n        type: \"JsdocTypeNullable\",\n        element: w(i),\n        meta: {\n          position: \"suffix\"\n        }\n      }) : null;\n    }, \"nullableParslet\");\n    function P(t) {\n      let o = /* @__PURE__ */ r((i, u, f) => {\n        let T = i.lexer.current.type, x = i.lexer.next.type;\n        if (f === null) {\n          if (\"parsePrefix\" in t && t.accept(T, x))\n            return t.parsePrefix(i);\n        } else if (\"parseInfix\" in t && t.precedence > u && t.accept(T, x))\n          return t.parseInfix(i, f);\n        return null;\n      }, \"parslet\");\n      return Object.defineProperty(o, \"name\", {\n        value: t.name\n      }), o;\n    }\n    r(P, \"composeParslet\");\n    let Ne = P({\n      name: \"optionalParslet\",\n      accept: /* @__PURE__ */ r((t) => t === \"=\", \"accept\"),\n      precedence: h.OPTIONAL,\n      parsePrefix: /* @__PURE__ */ r((t) => (t.consume(\"=\"), {\n        type: \"JsdocTypeOptional\",\n        element: t.parseType(h.OPTIONAL),\n        meta: {\n          position: \"prefix\"\n        }\n      }), \"parsePrefix\"),\n      parseInfix: /* @__PURE__ */ r((t, o) => (t.consume(\"=\"), {\n        type: \"JsdocTypeOptional\",\n        element: w(o),\n        meta: {\n          position: \"suffix\"\n        }\n      }), \"parseInfix\")\n    }), _e = P({\n      name: \"numberParslet\",\n      accept: /* @__PURE__ */ r((t) => t === \"Number\", \"accept\"),\n      parsePrefix: /* @__PURE__ */ r((t) => {\n        let o = parseFloat(t.lexer.current.text);\n        return t.consume(\"Number\"), {\n          type: \"JsdocTypeNumber\",\n          value: o\n        };\n      }, \"parsePrefix\")\n    }), hs = P({\n      name: \"parenthesisParslet\",\n      accept: /* @__PURE__ */ r((t) => t === \"(\", \"accept\"),\n      parsePrefix: /* @__PURE__ */ r((t) => {\n        if (t.consume(\"(\"), t.consume(\")\"))\n          return {\n            type: \"JsdocTypeParameterList\",\n            elements: []\n          };\n        let o = t.parseIntermediateType(h.ALL);\n        if (!t.consume(\")\"))\n          throw new Error(\"Unterminated parenthesis\");\n        return o.type === \"JsdocTypeParameterList\" ? o : o.type === \"JsdocTypeKeyValue\" ? {\n          type: \"JsdocTypeParameterList\",\n          elements: [o]\n        } : {\n          type: \"JsdocTypeParenthesis\",\n          element: w(o)\n        };\n      }, \"parsePrefix\")\n    }), xs = P({\n      name: \"specialTypesParslet\",\n      accept: /* @__PURE__ */ r((t, o) => t === \"?\" && Wt(o) || t === \"null\" || t === \"undefined\" || t === \"*\", \"accept\"),\n      parsePrefix: /* @__PURE__ */ r((t) => {\n        if (t.consume(\"null\"))\n          return {\n            type: \"JsdocTypeNull\"\n          };\n        if (t.consume(\"undefined\"))\n          return {\n            type: \"JsdocTypeUndefined\"\n          };\n        if (t.consume(\"*\"))\n          return {\n            type: \"JsdocTypeAny\"\n          };\n        if (t.consume(\"?\"))\n          return {\n            type: \"JsdocTypeUnknown\"\n          };\n        throw new Error(\"Unacceptable token: \" + t.lexer.current.text);\n      }, \"parsePrefix\")\n    }), bs = P({\n      name: \"notNullableParslet\",\n      accept: /* @__PURE__ */ r((t) => t === \"!\", \"accept\"),\n      precedence: h.NULLABLE,\n      parsePrefix: /* @__PURE__ */ r((t) => (t.consume(\"!\"), {\n        type: \"JsdocTypeNotNullable\",\n        element: t.parseType(h.NULLABLE),\n        meta: {\n          position: \"prefix\"\n        }\n      }), \"parsePrefix\"),\n      parseInfix: /* @__PURE__ */ r((t, o) => (t.consume(\"!\"), {\n        type: \"JsdocTypeNotNullable\",\n        element: w(o),\n        meta: {\n          position: \"suffix\"\n        }\n      }), \"parseInfix\")\n    });\n    function vs({ allowTrailingComma: t }) {\n      return P({\n        name: \"parameterListParslet\",\n        accept: /* @__PURE__ */ r((o) => o === \",\", \"accept\"),\n        precedence: h.PARAMETER_LIST,\n        parseInfix: /* @__PURE__ */ r((o, i) => {\n          let u = [\n            K(i)\n          ];\n          o.consume(\",\");\n          do\n            try {\n              let f = o.parseIntermediateType(h.PARAMETER_LIST);\n              u.push(K(f));\n            } catch (f) {\n              if (t && f instanceof a)\n                break;\n              throw f;\n            }\n          while (o.consume(\",\"));\n          if (u.length > 0 && u.slice(0, -1).some((f) => f.type === \"JsdocTypeVariadic\"))\n            throw new Error(\"Only the last parameter may be a rest parameter\");\n          return {\n            type: \"JsdocTypeParameterList\",\n            elements: u\n          };\n        }, \"parseInfix\")\n      });\n    }\n    r(vs, \"createParameterListParslet\");\n    let ws = P({\n      name: \"genericParslet\",\n      accept: /* @__PURE__ */ r((t, o) => t === \"<\" || t === \".\" && o === \"<\", \"accept\"),\n      precedence: h.GENERIC,\n      parseInfix: /* @__PURE__ */ r((t, o) => {\n        let i = t.consume(\".\");\n        t.consume(\"<\");\n        let u = [];\n        do\n          u.push(t.parseType(h.PARAMETER_LIST));\n        while (t.consume(\",\"));\n        if (!t.consume(\">\"))\n          throw new Error(\"Unterminated generic parameter list\");\n        return {\n          type: \"JsdocTypeGeneric\",\n          left: w(o),\n          elements: u,\n          meta: {\n            brackets: \"angle\",\n            dot: i\n          }\n        };\n      }, \"parseInfix\")\n    }), Ps = P({\n      name: \"unionParslet\",\n      accept: /* @__PURE__ */ r((t) => t === \"|\", \"accept\"),\n      precedence: h.UNION,\n      parseInfix: /* @__PURE__ */ r((t, o) => {\n        t.consume(\"|\");\n        let i = [];\n        do\n          i.push(t.parseType(h.UNION));\n        while (t.consume(\"|\"));\n        return {\n          type: \"JsdocTypeUnion\",\n          elements: [w(o), ...i]\n        };\n      }, \"parseInfix\")\n    }), nt = [\n      rt,\n      Ne,\n      _e,\n      hs,\n      xs,\n      bs,\n      vs({\n        allowTrailingComma: !0\n      }),\n      ws,\n      Ps,\n      Ne\n    ];\n    function De({ allowSquareBracketsOnAnyType: t, allowJsdocNamePaths: o, pathGrammar: i }) {\n      return /* @__PURE__ */ r(function(f, T, x) {\n        if (x == null || T >= h.NAME_PATH)\n          return null;\n        let S = f.lexer.current.type, D = f.lexer.next.type;\n        if (!(S === \".\" && D !== \"<\" || S === \"[\" && (t || x.type === \"JsdocTypeName\") || o && (S === \"~\" || S === \"#\")))\n          return null;\n        let j, Le = !1;\n        f.consume(\".\") ? j = \"property\" : f.consume(\"[\") ? (j = \"property-brackets\", Le = !0) : f.consume(\"~\") ? j = \"inner\" : (f.consume(\"#\"),\n        j = \"instance\");\n        let ir = i !== null ? new B(i, f.lexer, f) : f, U = ir.parseIntermediateType(h.NAME_PATH);\n        f.acceptLexerState(ir);\n        let ge;\n        switch (U.type) {\n          case \"JsdocTypeName\":\n            ge = {\n              type: \"JsdocTypeProperty\",\n              value: U.value,\n              meta: {\n                quote: void 0\n              }\n            };\n            break;\n          case \"JsdocTypeNumber\":\n            ge = {\n              type: \"JsdocTypeProperty\",\n              value: U.value.toString(10),\n              meta: {\n                quote: void 0\n              }\n            };\n            break;\n          case \"JsdocTypeStringValue\":\n            ge = {\n              type: \"JsdocTypeProperty\",\n              value: U.value,\n              meta: {\n                quote: U.meta.quote\n              }\n            };\n            break;\n          case \"JsdocTypeSpecialNamePath\":\n            if (U.specialType === \"event\")\n              ge = U;\n            else\n              throw new p(U, \"Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'\");\n            break;\n          default:\n            throw new p(U, \"Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'\");\n        }\n        if (Le && !f.consume(\"]\")) {\n          let sr = f.lexer.current;\n          throw new Error(`Unterminated square brackets. Next token is '${sr.type}' with text '${sr.text}'`);\n        }\n        return {\n          type: \"JsdocTypeNamePath\",\n          left: w(x),\n          right: ge,\n          pathType: j\n        };\n      }, \"namePathParslet\");\n    }\n    r(De, \"createNamePathParslet\");\n    function $({ allowedAdditionalTokens: t }) {\n      return P({\n        name: \"nameParslet\",\n        accept: /* @__PURE__ */ r((o) => o === \"Identifier\" || o === \"this\" || o === \"new\" || t.includes(o), \"accept\"),\n        parsePrefix: /* @__PURE__ */ r((o) => {\n          let { type: i, text: u } = o.lexer.current;\n          return o.consume(i), {\n            type: \"JsdocTypeName\",\n            value: u\n          };\n        }, \"parsePrefix\")\n      });\n    }\n    r($, \"createNameParslet\");\n    let me = P({\n      name: \"stringValueParslet\",\n      accept: /* @__PURE__ */ r((t) => t === \"StringValue\", \"accept\"),\n      parsePrefix: /* @__PURE__ */ r((t) => {\n        let o = t.lexer.current.text;\n        return t.consume(\"StringValue\"), {\n          type: \"JsdocTypeStringValue\",\n          value: o.slice(1, -1),\n          meta: {\n            quote: o[0] === \"'\" ? \"single\" : \"double\"\n          }\n        };\n      }, \"parsePrefix\")\n    });\n    function qe({ pathGrammar: t, allowedTypes: o }) {\n      return P({\n        name: \"specialNamePathParslet\",\n        accept: /* @__PURE__ */ r((i) => o.includes(i), \"accept\"),\n        parsePrefix: /* @__PURE__ */ r((i) => {\n          let u = i.lexer.current.type;\n          if (i.consume(u), !i.consume(\":\"))\n            return {\n              type: \"JsdocTypeName\",\n              value: u\n            };\n          let f, T = i.lexer.current;\n          if (i.consume(\"StringValue\"))\n            f = {\n              type: \"JsdocTypeSpecialNamePath\",\n              value: T.text.slice(1, -1),\n              specialType: u,\n              meta: {\n                quote: T.text[0] === \"'\" ? \"single\" : \"double\"\n              }\n            };\n          else {\n            let D = \"\", _ = [\"Identifier\", \"@\", \"/\"];\n            for (; _.some((j) => i.consume(j)); )\n              D += T.text, T = i.lexer.current;\n            f = {\n              type: \"JsdocTypeSpecialNamePath\",\n              value: D,\n              specialType: u,\n              meta: {\n                quote: void 0\n              }\n            };\n          }\n          let x = new B(t, i.lexer, i), S = x.parseInfixIntermediateType(f, h.ALL);\n          return i.acceptLexerState(x), w(S);\n        }, \"parsePrefix\")\n      });\n    }\n    r(qe, \"createSpecialNamePathParslet\");\n    let Xt = [\n      $({\n        allowedAdditionalTokens: [\"external\", \"module\"]\n      }),\n      me,\n      _e,\n      De({\n        allowSquareBracketsOnAnyType: !1,\n        allowJsdocNamePaths: !0,\n        pathGrammar: null\n      })\n    ], Z = [\n      ...Xt,\n      qe({\n        allowedTypes: [\"event\"],\n        pathGrammar: Xt\n      })\n    ];\n    function ot(t) {\n      let o;\n      if (t.type === \"JsdocTypeParameterList\")\n        o = t.elements;\n      else if (t.type === \"JsdocTypeParenthesis\")\n        o = [t.element];\n      else\n        throw new p(t);\n      return o.map((i) => K(i));\n    }\n    r(ot, \"getParameters\");\n    function Js(t) {\n      let o = ot(t);\n      if (o.some((i) => i.type === \"JsdocTypeKeyValue\"))\n        throw new Error(\"No parameter should be named\");\n      return o;\n    }\n    r(Js, \"getUnnamedParameters\");\n    function at({ allowNamedParameters: t, allowNoReturnType: o, allowWithoutParenthesis: i, allowNewAsFunctionKeyword: u }) {\n      return P({\n        name: \"functionParslet\",\n        accept: /* @__PURE__ */ r((f, T) => f === \"function\" || u && f === \"new\" && T === \"(\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ r((f) => {\n          let T = f.consume(\"new\");\n          f.consume(\"function\");\n          let x = f.lexer.current.type === \"(\";\n          if (!x) {\n            if (!i)\n              throw new Error(\"function is missing parameter list\");\n            return {\n              type: \"JsdocTypeName\",\n              value: \"function\"\n            };\n          }\n          let S = {\n            type: \"JsdocTypeFunction\",\n            parameters: [],\n            arrow: !1,\n            constructor: T,\n            parenthesis: x\n          }, D = f.parseIntermediateType(h.FUNCTION);\n          if (t === void 0)\n            S.parameters = Js(D);\n          else {\n            if (T && D.type === \"JsdocTypeFunction\" && D.arrow)\n              return S = D, S.constructor = !0, S;\n            S.parameters = ot(D);\n            for (let _ of S.parameters)\n              if (_.type === \"JsdocTypeKeyValue\" && !t.includes(_.key))\n                throw new Error(`only allowed named parameters are ${t.join(\", \")} but got ${_.type}`);\n          }\n          if (f.consume(\":\"))\n            S.returnType = f.parseType(h.PREFIX);\n          else if (!o)\n            throw new Error(\"function is missing return type\");\n          return S;\n        }, \"parsePrefix\")\n      });\n    }\n    r(at, \"createFunctionParslet\");\n    function it({ allowPostfix: t, allowEnclosingBrackets: o }) {\n      return P({\n        name: \"variadicParslet\",\n        accept: /* @__PURE__ */ r((i) => i === \"...\", \"accept\"),\n        precedence: h.PREFIX,\n        parsePrefix: /* @__PURE__ */ r((i) => {\n          i.consume(\"...\");\n          let u = o && i.consume(\"[\");\n          try {\n            let f = i.parseType(h.PREFIX);\n            if (u && !i.consume(\"]\"))\n              throw new Error(\"Unterminated variadic type. Missing ']'\");\n            return {\n              type: \"JsdocTypeVariadic\",\n              element: w(f),\n              meta: {\n                position: \"prefix\",\n                squareBrackets: u\n              }\n            };\n          } catch (f) {\n            if (f instanceof a) {\n              if (u)\n                throw new Error(\"Empty square brackets for variadic are not allowed.\");\n              return {\n                type: \"JsdocTypeVariadic\",\n                meta: {\n                  position: void 0,\n                  squareBrackets: !1\n                }\n              };\n            } else\n              throw f;\n          }\n        }, \"parsePrefix\"),\n        parseInfix: t ? (i, u) => (i.consume(\"...\"), {\n          type: \"JsdocTypeVariadic\",\n          element: w(u),\n          meta: {\n            position: \"suffix\",\n            squareBrackets: !1\n          }\n        }) : void 0\n      });\n    }\n    r(it, \"createVariadicParslet\");\n    let Qt = P({\n      name: \"symbolParslet\",\n      accept: /* @__PURE__ */ r((t) => t === \"(\", \"accept\"),\n      precedence: h.SYMBOL,\n      parseInfix: /* @__PURE__ */ r((t, o) => {\n        if (o.type !== \"JsdocTypeName\")\n          throw new Error(\"Symbol expects a name on the left side. (Reacting on '(')\");\n        t.consume(\"(\");\n        let i = {\n          type: \"JsdocTypeSymbol\",\n          value: o.value\n        };\n        if (!t.consume(\")\")) {\n          let u = t.parseIntermediateType(h.SYMBOL);\n          if (i.element = gs(u), !t.consume(\")\"))\n            throw new Error(\"Symbol does not end after value\");\n        }\n        return i;\n      }, \"parseInfix\")\n    }), Zt = P({\n      name: \"arrayBracketsParslet\",\n      precedence: h.ARRAY_BRACKETS,\n      accept: /* @__PURE__ */ r((t, o) => t === \"[\" && o === \"]\", \"accept\"),\n      parseInfix: /* @__PURE__ */ r((t, o) => (t.consume(\"[\"), t.consume(\"]\"), {\n        type: \"JsdocTypeGeneric\",\n        left: {\n          type: \"JsdocTypeName\",\n          value: \"Array\"\n        },\n        elements: [\n          w(o)\n        ],\n        meta: {\n          brackets: \"square\",\n          dot: !1\n        }\n      }), \"parseInfix\")\n    });\n    function st({ objectFieldGrammar: t, allowKeyTypes: o }) {\n      return P({\n        name: \"objectParslet\",\n        accept: /* @__PURE__ */ r((i) => i === \"{\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ r((i) => {\n          i.consume(\"{\");\n          let u = {\n            type: \"JsdocTypeObject\",\n            meta: {\n              separator: \"comma\"\n            },\n            elements: []\n          };\n          if (!i.consume(\"}\")) {\n            let f, T = new B(t, i.lexer, i);\n            for (; ; ) {\n              T.acceptLexerState(i);\n              let x = T.parseIntermediateType(h.OBJECT);\n              i.acceptLexerState(T), x === void 0 && o && (x = i.parseIntermediateType(h.OBJECT));\n              let S = !1;\n              if (x.type === \"JsdocTypeNullable\" && (S = !0, x = x.element), x.type === \"JsdocTypeNumber\" || x.type === \"JsdocTypeName\" || x.\n              type === \"JsdocTypeStringValue\") {\n                let _;\n                x.type === \"JsdocTypeStringValue\" && (_ = x.meta.quote), u.elements.push({\n                  type: \"JsdocTypeObjectField\",\n                  key: x.value.toString(),\n                  right: void 0,\n                  optional: S,\n                  readonly: !1,\n                  meta: {\n                    quote: _\n                  }\n                });\n              } else if (x.type === \"JsdocTypeObjectField\" || x.type === \"JsdocTypeJsdocObjectField\")\n                u.elements.push(x);\n              else\n                throw new p(x);\n              if (i.lexer.current.startOfLine)\n                f = \"linebreak\";\n              else if (i.consume(\",\"))\n                f = \"comma\";\n              else if (i.consume(\";\"))\n                f = \"semicolon\";\n              else\n                break;\n              if (i.lexer.current.type === \"}\")\n                break;\n            }\n            if (u.meta.separator = f ?? \"comma\", !i.consume(\"}\"))\n              throw new Error(\"Unterminated record type. Missing '}'\");\n          }\n          return u;\n        }, \"parsePrefix\")\n      });\n    }\n    r(st, \"createObjectParslet\");\n    function pt({ allowSquaredProperties: t, allowKeyTypes: o, allowReadonly: i, allowOptional: u }) {\n      return P({\n        name: \"objectFieldParslet\",\n        precedence: h.KEY_VALUE,\n        accept: /* @__PURE__ */ r((f) => f === \":\", \"accept\"),\n        parseInfix: /* @__PURE__ */ r((f, T) => {\n          var x;\n          let S = !1, D = !1;\n          u && T.type === \"JsdocTypeNullable\" && (S = !0, T = T.element), i && T.type === \"JsdocTypeReadonlyProperty\" && (D = !0, T = T.element);\n          let _ = (x = f.baseParser) !== null && x !== void 0 ? x : f;\n          if (_.acceptLexerState(f), T.type === \"JsdocTypeNumber\" || T.type === \"JsdocTypeName\" || T.type === \"JsdocTypeStringValue\" || tt(T)) {\n            if (tt(T) && !t)\n              throw new p(T);\n            _.consume(\":\");\n            let j;\n            T.type === \"JsdocTypeStringValue\" && (j = T.meta.quote);\n            let Le = _.parseType(h.KEY_VALUE);\n            return f.acceptLexerState(_), {\n              type: \"JsdocTypeObjectField\",\n              key: tt(T) ? T : T.value.toString(),\n              right: Le,\n              optional: S,\n              readonly: D,\n              meta: {\n                quote: j\n              }\n            };\n          } else {\n            if (!o)\n              throw new p(T);\n            _.consume(\":\");\n            let j = _.parseType(h.KEY_VALUE);\n            return f.acceptLexerState(_), {\n              type: \"JsdocTypeJsdocObjectField\",\n              left: w(T),\n              right: j\n            };\n          }\n        }, \"parseInfix\")\n      });\n    }\n    r(pt, \"createObjectFieldParslet\");\n    function ct({ allowOptional: t, allowVariadic: o }) {\n      return P({\n        name: \"keyValueParslet\",\n        precedence: h.KEY_VALUE,\n        accept: /* @__PURE__ */ r((i) => i === \":\", \"accept\"),\n        parseInfix: /* @__PURE__ */ r((i, u) => {\n          let f = !1, T = !1;\n          if (t && u.type === \"JsdocTypeNullable\" && (f = !0, u = u.element), o && u.type === \"JsdocTypeVariadic\" && u.element !== void 0 &&\n          (T = !0, u = u.element), u.type !== \"JsdocTypeName\")\n            throw new p(u);\n          i.consume(\":\");\n          let x = i.parseType(h.KEY_VALUE);\n          return {\n            type: \"JsdocTypeKeyValue\",\n            key: u.value,\n            right: x,\n            optional: f,\n            variadic: T\n          };\n        }, \"parseInfix\")\n      });\n    }\n    r(ct, \"createKeyValueParslet\");\n    let er = [\n      ...nt,\n      at({\n        allowWithoutParenthesis: !0,\n        allowNamedParameters: [\"this\", \"new\"],\n        allowNoReturnType: !0,\n        allowNewAsFunctionKeyword: !1\n      }),\n      me,\n      qe({\n        allowedTypes: [\"module\", \"external\", \"event\"],\n        pathGrammar: Z\n      }),\n      it({\n        allowEnclosingBrackets: !0,\n        allowPostfix: !0\n      }),\n      $({\n        allowedAdditionalTokens: [\"keyof\"]\n      }),\n      Qt,\n      Zt,\n      De({\n        allowSquareBracketsOnAnyType: !1,\n        allowJsdocNamePaths: !0,\n        pathGrammar: Z\n      })\n    ], Ss = [\n      ...er,\n      st({\n        // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here\n        // we leave out the object type deliberately\n        objectFieldGrammar: [\n          $({\n            allowedAdditionalTokens: [\"module\", \"in\"]\n          }),\n          pt({\n            allowSquaredProperties: !1,\n            allowKeyTypes: !0,\n            allowOptional: !1,\n            allowReadonly: !1\n          }),\n          ...er\n        ],\n        allowKeyTypes: !0\n      }),\n      ct({\n        allowOptional: !0,\n        allowVariadic: !0\n      })\n    ], tr = P({\n      name: \"typeOfParslet\",\n      accept: /* @__PURE__ */ r((t) => t === \"typeof\", \"accept\"),\n      parsePrefix: /* @__PURE__ */ r((t) => (t.consume(\"typeof\"), {\n        type: \"JsdocTypeTypeof\",\n        element: w(t.parseType(h.KEY_OF_TYPE_OF))\n      }), \"parsePrefix\")\n    }), Es = [\n      $({\n        allowedAdditionalTokens: [\"module\", \"keyof\", \"event\", \"external\", \"in\"]\n      }),\n      rt,\n      Ne,\n      me,\n      _e,\n      pt({\n        allowSquaredProperties: !1,\n        allowKeyTypes: !1,\n        allowOptional: !1,\n        allowReadonly: !1\n      })\n    ], Os = [\n      ...nt,\n      st({\n        allowKeyTypes: !1,\n        objectFieldGrammar: Es\n      }),\n      $({\n        allowedAdditionalTokens: [\"event\", \"external\", \"in\"]\n      }),\n      tr,\n      at({\n        allowWithoutParenthesis: !1,\n        allowNamedParameters: [\"this\", \"new\"],\n        allowNoReturnType: !0,\n        allowNewAsFunctionKeyword: !1\n      }),\n      it({\n        allowEnclosingBrackets: !1,\n        allowPostfix: !1\n      }),\n      // additional name parslet is needed for some special cases\n      $({\n        allowedAdditionalTokens: [\"keyof\"]\n      }),\n      qe({\n        allowedTypes: [\"module\"],\n        pathGrammar: Z\n      }),\n      De({\n        allowSquareBracketsOnAnyType: !1,\n        allowJsdocNamePaths: !0,\n        pathGrammar: Z\n      }),\n      ct({\n        allowOptional: !1,\n        allowVariadic: !1\n      }),\n      Qt\n    ];\n    function As({ allowQuestionMark: t }) {\n      return P({\n        name: \"tupleParslet\",\n        accept: /* @__PURE__ */ r((o) => o === \"[\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ r((o) => {\n          o.consume(\"[\");\n          let i = {\n            type: \"JsdocTypeTuple\",\n            elements: []\n          };\n          if (o.consume(\"]\"))\n            return i;\n          let u = o.parseIntermediateType(h.ALL);\n          if (u.type === \"JsdocTypeParameterList\" ? u.elements[0].type === \"JsdocTypeKeyValue\" ? i.elements = u.elements.map(Ae) : i.elements =\n          u.elements.map(w) : u.type === \"JsdocTypeKeyValue\" ? i.elements = [Ae(u)] : i.elements = [w(u)], !o.consume(\"]\"))\n            throw new Error(\"Unterminated '['\");\n          if (!t && i.elements.some((f) => f.type === \"JsdocTypeUnknown\"))\n            throw new Error(\"Question mark in tuple not allowed\");\n          return i;\n        }, \"parsePrefix\")\n      });\n    }\n    r(As, \"createTupleParslet\");\n    let Ns = P({\n      name: \"keyOfParslet\",\n      accept: /* @__PURE__ */ r((t) => t === \"keyof\", \"accept\"),\n      parsePrefix: /* @__PURE__ */ r((t) => (t.consume(\"keyof\"), {\n        type: \"JsdocTypeKeyof\",\n        element: w(t.parseType(h.KEY_OF_TYPE_OF))\n      }), \"parsePrefix\")\n    }), _s = P({\n      name: \"importParslet\",\n      accept: /* @__PURE__ */ r((t) => t === \"import\", \"accept\"),\n      parsePrefix: /* @__PURE__ */ r((t) => {\n        if (t.consume(\"import\"), !t.consume(\"(\"))\n          throw new Error(\"Missing parenthesis after import keyword\");\n        let o = t.parseType(h.PREFIX);\n        if (o.type !== \"JsdocTypeStringValue\")\n          throw new Error(\"Only string values are allowed as paths for imports\");\n        if (!t.consume(\")\"))\n          throw new Error(\"Missing closing parenthesis after import keyword\");\n        return {\n          type: \"JsdocTypeImport\",\n          element: o\n        };\n      }, \"parsePrefix\")\n    }), Ds = P({\n      name: \"readonlyPropertyParslet\",\n      accept: /* @__PURE__ */ r((t) => t === \"readonly\", \"accept\"),\n      parsePrefix: /* @__PURE__ */ r((t) => (t.consume(\"readonly\"), {\n        type: \"JsdocTypeReadonlyProperty\",\n        element: t.parseType(h.KEY_VALUE)\n      }), \"parsePrefix\")\n    }), qs = P({\n      name: \"arrowFunctionParslet\",\n      precedence: h.ARROW,\n      accept: /* @__PURE__ */ r((t) => t === \"=>\", \"accept\"),\n      parseInfix: /* @__PURE__ */ r((t, o) => (t.consume(\"=>\"), {\n        type: \"JsdocTypeFunction\",\n        parameters: ot(o).map(Ts),\n        arrow: !0,\n        constructor: !1,\n        parenthesis: !0,\n        returnType: t.parseType(h.OBJECT)\n      }), \"parseInfix\")\n    }), Is = P({\n      name: \"intersectionParslet\",\n      accept: /* @__PURE__ */ r((t) => t === \"&\", \"accept\"),\n      precedence: h.INTERSECTION,\n      parseInfix: /* @__PURE__ */ r((t, o) => {\n        t.consume(\"&\");\n        let i = [];\n        do\n          i.push(t.parseType(h.INTERSECTION));\n        while (t.consume(\"&\"));\n        return {\n          type: \"JsdocTypeIntersection\",\n          elements: [w(o), ...i]\n        };\n      }, \"parseInfix\")\n    }), Rs = P({\n      name: \"predicateParslet\",\n      precedence: h.INFIX,\n      accept: /* @__PURE__ */ r((t) => t === \"is\", \"accept\"),\n      parseInfix: /* @__PURE__ */ r((t, o) => {\n        if (o.type !== \"JsdocTypeName\")\n          throw new p(o, \"A typescript predicate always has to have a name on the left side.\");\n        return t.consume(\"is\"), {\n          type: \"JsdocTypePredicate\",\n          left: o,\n          right: w(t.parseIntermediateType(h.INFIX))\n        };\n      }, \"parseInfix\")\n    }), js = P({\n      name: \"objectSquareBracketPropertyParslet\",\n      accept: /* @__PURE__ */ r((t) => t === \"[\", \"accept\"),\n      parsePrefix: /* @__PURE__ */ r((t) => {\n        if (t.baseParser === void 0)\n          throw new Error(\"Only allowed inside object grammar\");\n        t.consume(\"[\");\n        let o = t.lexer.current.text;\n        t.consume(\"Identifier\");\n        let i;\n        if (t.consume(\":\")) {\n          let u = t.baseParser;\n          u.acceptLexerState(t), i = {\n            type: \"JsdocTypeIndexSignature\",\n            key: o,\n            right: u.parseType(h.ARRAY_BRACKETS)\n          }, t.acceptLexerState(u);\n        } else if (t.consume(\"in\")) {\n          let u = t.baseParser;\n          u.acceptLexerState(t), i = {\n            type: \"JsdocTypeMappedType\",\n            key: o,\n            right: u.parseType(h.ARRAY_BRACKETS)\n          }, t.acceptLexerState(u);\n        } else\n          throw new Error(\"Missing ':' or 'in' inside square bracketed property.\");\n        if (!t.consume(\"]\"))\n          throw new Error(\"Unterminated square brackets\");\n        return i;\n      }, \"parsePrefix\")\n    }), Fs = [\n      Ds,\n      $({\n        allowedAdditionalTokens: [\"module\", \"event\", \"keyof\", \"event\", \"external\", \"in\"]\n      }),\n      rt,\n      Ne,\n      me,\n      _e,\n      pt({\n        allowSquaredProperties: !0,\n        allowKeyTypes: !1,\n        allowOptional: !0,\n        allowReadonly: !0\n      }),\n      js\n    ], Ls = [\n      ...nt,\n      st({\n        allowKeyTypes: !1,\n        objectFieldGrammar: Fs\n      }),\n      tr,\n      Ns,\n      _s,\n      me,\n      at({\n        allowWithoutParenthesis: !0,\n        allowNoReturnType: !1,\n        allowNamedParameters: [\"this\", \"new\", \"args\"],\n        allowNewAsFunctionKeyword: !0\n      }),\n      As({\n        allowQuestionMark: !1\n      }),\n      it({\n        allowEnclosingBrackets: !1,\n        allowPostfix: !1\n      }),\n      $({\n        allowedAdditionalTokens: [\"event\", \"external\", \"in\"]\n      }),\n      qe({\n        allowedTypes: [\"module\"],\n        pathGrammar: Z\n      }),\n      Zt,\n      qs,\n      De({\n        allowSquareBracketsOnAnyType: !0,\n        allowJsdocNamePaths: !1,\n        pathGrammar: Z\n      }),\n      Is,\n      Rs,\n      ct({\n        allowVariadic: !0,\n        allowOptional: !0\n      })\n    ];\n    function rr(t, o) {\n      switch (o) {\n        case \"closure\":\n          return new B(Os, t).parse();\n        case \"jsdoc\":\n          return new B(Ss, t).parse();\n        case \"typescript\":\n          return new B(Ls, t).parse();\n      }\n    }\n    r(rr, \"parse\");\n    function ks(t, o = [\"typescript\", \"closure\", \"jsdoc\"]) {\n      let i;\n      for (let u of o)\n        try {\n          return rr(t, u);\n        } catch (f) {\n          i = f;\n        }\n      throw i;\n    }\n    r(ks, \"tryParse\");\n    function Te(t, o) {\n      let i = t[o.type];\n      if (i === void 0)\n        throw new Error(`In this set of transform rules exists no rule for type ${o.type}.`);\n      return i(o, (u) => Te(t, u));\n    }\n    r(Te, \"transform\");\n    function I(t) {\n      throw new Error(\"This transform is not available. Are you trying the correct parsing mode?\");\n    }\n    r(I, \"notAvailableTransform\");\n    function nr(t) {\n      let o = {\n        params: []\n      };\n      for (let i of t.parameters)\n        i.type === \"JsdocTypeKeyValue\" ? i.key === \"this\" ? o.this = i.right : i.key === \"new\" ? o.new = i.right : o.params.push(i) : o.params.\n        push(i);\n      return o;\n    }\n    r(nr, \"extractSpecialParams\");\n    function Ie(t, o, i) {\n      return t === \"prefix\" ? i + o : o + i;\n    }\n    r(Ie, \"applyPosition\");\n    function G(t, o) {\n      switch (o) {\n        case \"double\":\n          return `\"${t}\"`;\n        case \"single\":\n          return `'${t}'`;\n        case void 0:\n          return t;\n      }\n    }\n    r(G, \"quote\");\n    function or() {\n      return {\n        JsdocTypeParenthesis: /* @__PURE__ */ r((t, o) => `(${t.element !== void 0 ? o(t.element) : \"\"})`, \"JsdocTypeParenthesis\"),\n        JsdocTypeKeyof: /* @__PURE__ */ r((t, o) => `keyof ${o(t.element)}`, \"JsdocTypeKeyof\"),\n        JsdocTypeFunction: /* @__PURE__ */ r((t, o) => {\n          if (t.arrow) {\n            if (t.returnType === void 0)\n              throw new Error(\"Arrow function needs a return type.\");\n            let i = `(${t.parameters.map(o).join(\", \")}) => ${o(t.returnType)}`;\n            return t.constructor && (i = \"new \" + i), i;\n          } else {\n            let i = t.constructor ? \"new\" : \"function\";\n            return t.parenthesis && (i += `(${t.parameters.map(o).join(\", \")})`, t.returnType !== void 0 && (i += `: ${o(t.returnType)}`)), i;\n          }\n        }, \"JsdocTypeFunction\"),\n        JsdocTypeName: /* @__PURE__ */ r((t) => t.value, \"JsdocTypeName\"),\n        JsdocTypeTuple: /* @__PURE__ */ r((t, o) => `[${t.elements.map(o).join(\", \")}]`, \"JsdocTypeTuple\"),\n        JsdocTypeVariadic: /* @__PURE__ */ r((t, o) => t.meta.position === void 0 ? \"...\" : Ie(t.meta.position, o(t.element), \"...\"), \"Jsdoc\\\nTypeVariadic\"),\n        JsdocTypeNamePath: /* @__PURE__ */ r((t, o) => {\n          let i = o(t.left), u = o(t.right);\n          switch (t.pathType) {\n            case \"inner\":\n              return `${i}~${u}`;\n            case \"instance\":\n              return `${i}#${u}`;\n            case \"property\":\n              return `${i}.${u}`;\n            case \"property-brackets\":\n              return `${i}[${u}]`;\n          }\n        }, \"JsdocTypeNamePath\"),\n        JsdocTypeStringValue: /* @__PURE__ */ r((t) => G(t.value, t.meta.quote), \"JsdocTypeStringValue\"),\n        JsdocTypeAny: /* @__PURE__ */ r(() => \"*\", \"JsdocTypeAny\"),\n        JsdocTypeGeneric: /* @__PURE__ */ r((t, o) => {\n          if (t.meta.brackets === \"square\") {\n            let i = t.elements[0], u = o(i);\n            return i.type === \"JsdocTypeUnion\" || i.type === \"JsdocTypeIntersection\" ? `(${u})[]` : `${u}[]`;\n          } else\n            return `${o(t.left)}${t.meta.dot ? \".\" : \"\"}<${t.elements.map(o).join(\", \")}>`;\n        }, \"JsdocTypeGeneric\"),\n        JsdocTypeImport: /* @__PURE__ */ r((t, o) => `import(${o(t.element)})`, \"JsdocTypeImport\"),\n        JsdocTypeObjectField: /* @__PURE__ */ r((t, o) => {\n          let i = \"\";\n          return t.readonly && (i += \"readonly \"), typeof t.key == \"string\" ? i += G(t.key, t.meta.quote) : i += o(t.key), t.optional && (i +=\n          \"?\"), t.right === void 0 ? i : i + `: ${o(t.right)}`;\n        }, \"JsdocTypeObjectField\"),\n        JsdocTypeJsdocObjectField: /* @__PURE__ */ r((t, o) => `${o(t.left)}: ${o(t.right)}`, \"JsdocTypeJsdocObjectField\"),\n        JsdocTypeKeyValue: /* @__PURE__ */ r((t, o) => {\n          let i = t.key;\n          return t.optional && (i += \"?\"), t.variadic && (i = \"...\" + i), t.right === void 0 ? i : i + `: ${o(t.right)}`;\n        }, \"JsdocTypeKeyValue\"),\n        JsdocTypeSpecialNamePath: /* @__PURE__ */ r((t) => `${t.specialType}:${G(t.value, t.meta.quote)}`, \"JsdocTypeSpecialNamePath\"),\n        JsdocTypeNotNullable: /* @__PURE__ */ r((t, o) => Ie(t.meta.position, o(t.element), \"!\"), \"JsdocTypeNotNullable\"),\n        JsdocTypeNull: /* @__PURE__ */ r(() => \"null\", \"JsdocTypeNull\"),\n        JsdocTypeNullable: /* @__PURE__ */ r((t, o) => Ie(t.meta.position, o(t.element), \"?\"), \"JsdocTypeNullable\"),\n        JsdocTypeNumber: /* @__PURE__ */ r((t) => t.value.toString(), \"JsdocTypeNumber\"),\n        JsdocTypeObject: /* @__PURE__ */ r((t, o) => `{${t.elements.map(o).join((t.meta.separator === \"comma\" ? \",\" : \";\") + \" \")}}`, \"Jsdoc\\\nTypeObject\"),\n        JsdocTypeOptional: /* @__PURE__ */ r((t, o) => Ie(t.meta.position, o(t.element), \"=\"), \"JsdocTypeOptional\"),\n        JsdocTypeSymbol: /* @__PURE__ */ r((t, o) => `${t.value}(${t.element !== void 0 ? o(t.element) : \"\"})`, \"JsdocTypeSymbol\"),\n        JsdocTypeTypeof: /* @__PURE__ */ r((t, o) => `typeof ${o(t.element)}`, \"JsdocTypeTypeof\"),\n        JsdocTypeUndefined: /* @__PURE__ */ r(() => \"undefined\", \"JsdocTypeUndefined\"),\n        JsdocTypeUnion: /* @__PURE__ */ r((t, o) => t.elements.map(o).join(\" | \"), \"JsdocTypeUnion\"),\n        JsdocTypeUnknown: /* @__PURE__ */ r(() => \"?\", \"JsdocTypeUnknown\"),\n        JsdocTypeIntersection: /* @__PURE__ */ r((t, o) => t.elements.map(o).join(\" & \"), \"JsdocTypeIntersection\"),\n        JsdocTypeProperty: /* @__PURE__ */ r((t) => G(t.value, t.meta.quote), \"JsdocTypeProperty\"),\n        JsdocTypePredicate: /* @__PURE__ */ r((t, o) => `${o(t.left)} is ${o(t.right)}`, \"JsdocTypePredicate\"),\n        JsdocTypeIndexSignature: /* @__PURE__ */ r((t, o) => `[${t.key}: ${o(t.right)}]`, \"JsdocTypeIndexSignature\"),\n        JsdocTypeMappedType: /* @__PURE__ */ r((t, o) => `[${t.key} in ${o(t.right)}]`, \"JsdocTypeMappedType\")\n      };\n    }\n    r(or, \"stringifyRules\");\n    let Cs = or();\n    function Us(t) {\n      return Te(Cs, t);\n    }\n    r(Us, \"stringify\");\n    let Ms = [\n      \"null\",\n      \"true\",\n      \"false\",\n      \"break\",\n      \"case\",\n      \"catch\",\n      \"class\",\n      \"const\",\n      \"continue\",\n      \"debugger\",\n      \"default\",\n      \"delete\",\n      \"do\",\n      \"else\",\n      \"export\",\n      \"extends\",\n      \"finally\",\n      \"for\",\n      \"function\",\n      \"if\",\n      \"import\",\n      \"in\",\n      \"instanceof\",\n      \"new\",\n      \"return\",\n      \"super\",\n      \"switch\",\n      \"this\",\n      \"throw\",\n      \"try\",\n      \"typeof\",\n      \"var\",\n      \"void\",\n      \"while\",\n      \"with\",\n      \"yield\"\n    ];\n    function Y(t) {\n      let o = {\n        type: \"NameExpression\",\n        name: t\n      };\n      return Ms.includes(t) && (o.reservedWord = !0), o;\n    }\n    r(Y, \"makeName\");\n    let Vs = {\n      JsdocTypeOptional: /* @__PURE__ */ r((t, o) => {\n        let i = o(t.element);\n        return i.optional = !0, i;\n      }, \"JsdocTypeOptional\"),\n      JsdocTypeNullable: /* @__PURE__ */ r((t, o) => {\n        let i = o(t.element);\n        return i.nullable = !0, i;\n      }, \"JsdocTypeNullable\"),\n      JsdocTypeNotNullable: /* @__PURE__ */ r((t, o) => {\n        let i = o(t.element);\n        return i.nullable = !1, i;\n      }, \"JsdocTypeNotNullable\"),\n      JsdocTypeVariadic: /* @__PURE__ */ r((t, o) => {\n        if (t.element === void 0)\n          throw new Error(\"dots without value are not allowed in catharsis mode\");\n        let i = o(t.element);\n        return i.repeatable = !0, i;\n      }, \"JsdocTypeVariadic\"),\n      JsdocTypeAny: /* @__PURE__ */ r(() => ({\n        type: \"AllLiteral\"\n      }), \"JsdocTypeAny\"),\n      JsdocTypeNull: /* @__PURE__ */ r(() => ({\n        type: \"NullLiteral\"\n      }), \"JsdocTypeNull\"),\n      JsdocTypeStringValue: /* @__PURE__ */ r((t) => Y(G(t.value, t.meta.quote)), \"JsdocTypeStringValue\"),\n      JsdocTypeUndefined: /* @__PURE__ */ r(() => ({\n        type: \"UndefinedLiteral\"\n      }), \"JsdocTypeUndefined\"),\n      JsdocTypeUnknown: /* @__PURE__ */ r(() => ({\n        type: \"UnknownLiteral\"\n      }), \"JsdocTypeUnknown\"),\n      JsdocTypeFunction: /* @__PURE__ */ r((t, o) => {\n        let i = nr(t), u = {\n          type: \"FunctionType\",\n          params: i.params.map(o)\n        };\n        return i.this !== void 0 && (u.this = o(i.this)), i.new !== void 0 && (u.new = o(i.new)), t.returnType !== void 0 && (u.result = o(t.\n        returnType)), u;\n      }, \"JsdocTypeFunction\"),\n      JsdocTypeGeneric: /* @__PURE__ */ r((t, o) => ({\n        type: \"TypeApplication\",\n        applications: t.elements.map((i) => o(i)),\n        expression: o(t.left)\n      }), \"JsdocTypeGeneric\"),\n      JsdocTypeSpecialNamePath: /* @__PURE__ */ r((t) => Y(t.specialType + \":\" + G(t.value, t.meta.quote)), \"JsdocTypeSpecialNamePath\"),\n      JsdocTypeName: /* @__PURE__ */ r((t) => t.value !== \"function\" ? Y(t.value) : {\n        type: \"FunctionType\",\n        params: []\n      }, \"JsdocTypeName\"),\n      JsdocTypeNumber: /* @__PURE__ */ r((t) => Y(t.value.toString()), \"JsdocTypeNumber\"),\n      JsdocTypeObject: /* @__PURE__ */ r((t, o) => {\n        let i = {\n          type: \"RecordType\",\n          fields: []\n        };\n        for (let u of t.elements)\n          u.type !== \"JsdocTypeObjectField\" && u.type !== \"JsdocTypeJsdocObjectField\" ? i.fields.push({\n            type: \"FieldType\",\n            key: o(u),\n            value: void 0\n          }) : i.fields.push(o(u));\n        return i;\n      }, \"JsdocTypeObject\"),\n      JsdocTypeObjectField: /* @__PURE__ */ r((t, o) => {\n        if (typeof t.key != \"string\")\n          throw new Error(\"Index signatures and mapped types are not supported\");\n        return {\n          type: \"FieldType\",\n          key: Y(G(t.key, t.meta.quote)),\n          value: t.right === void 0 ? void 0 : o(t.right)\n        };\n      }, \"JsdocTypeObjectField\"),\n      JsdocTypeJsdocObjectField: /* @__PURE__ */ r((t, o) => ({\n        type: \"FieldType\",\n        key: o(t.left),\n        value: o(t.right)\n      }), \"JsdocTypeJsdocObjectField\"),\n      JsdocTypeUnion: /* @__PURE__ */ r((t, o) => ({\n        type: \"TypeUnion\",\n        elements: t.elements.map((i) => o(i))\n      }), \"JsdocTypeUnion\"),\n      JsdocTypeKeyValue: /* @__PURE__ */ r((t, o) => ({\n        type: \"FieldType\",\n        key: Y(t.key),\n        value: t.right === void 0 ? void 0 : o(t.right)\n      }), \"JsdocTypeKeyValue\"),\n      JsdocTypeNamePath: /* @__PURE__ */ r((t, o) => {\n        let i = o(t.left), u;\n        t.right.type === \"JsdocTypeSpecialNamePath\" ? u = o(t.right).name : u = G(t.right.value, t.right.meta.quote);\n        let f = t.pathType === \"inner\" ? \"~\" : t.pathType === \"instance\" ? \"#\" : \".\";\n        return Y(`${i.name}${f}${u}`);\n      }, \"JsdocTypeNamePath\"),\n      JsdocTypeSymbol: /* @__PURE__ */ r((t) => {\n        let o = \"\", i = t.element, u = !1;\n        return i?.type === \"JsdocTypeVariadic\" && (i.meta.position === \"prefix\" ? o = \"...\" : u = !0, i = i.element), i?.type === \"JsdocType\\\nName\" ? o += i.value : i?.type === \"JsdocTypeNumber\" && (o += i.value.toString()), u && (o += \"...\"), Y(`${t.value}(${o})`);\n      }, \"JsdocTypeSymbol\"),\n      JsdocTypeParenthesis: /* @__PURE__ */ r((t, o) => o(w(t.element)), \"JsdocTypeParenthesis\"),\n      JsdocTypeMappedType: I,\n      JsdocTypeIndexSignature: I,\n      JsdocTypeImport: I,\n      JsdocTypeKeyof: I,\n      JsdocTypeTuple: I,\n      JsdocTypeTypeof: I,\n      JsdocTypeIntersection: I,\n      JsdocTypeProperty: I,\n      JsdocTypePredicate: I\n    };\n    function Ks(t) {\n      return Te(Vs, t);\n    }\n    r(Ks, \"catharsisTransform\");\n    function W(t) {\n      switch (t) {\n        case void 0:\n          return \"none\";\n        case \"single\":\n          return \"single\";\n        case \"double\":\n          return \"double\";\n      }\n    }\n    r(W, \"getQuoteStyle\");\n    function Bs(t) {\n      switch (t) {\n        case \"inner\":\n          return \"INNER_MEMBER\";\n        case \"instance\":\n          return \"INSTANCE_MEMBER\";\n        case \"property\":\n          return \"MEMBER\";\n        case \"property-brackets\":\n          return \"MEMBER\";\n      }\n    }\n    r(Bs, \"getMemberType\");\n    function ut(t, o) {\n      return o.length === 2 ? {\n        type: t,\n        left: o[0],\n        right: o[1]\n      } : {\n        type: t,\n        left: o[0],\n        right: ut(t, o.slice(1))\n      };\n    }\n    r(ut, \"nestResults\");\n    let $s = {\n      JsdocTypeOptional: /* @__PURE__ */ r((t, o) => ({\n        type: \"OPTIONAL\",\n        value: o(t.element),\n        meta: {\n          syntax: t.meta.position === \"prefix\" ? \"PREFIX_EQUAL_SIGN\" : \"SUFFIX_EQUALS_SIGN\"\n        }\n      }), \"JsdocTypeOptional\"),\n      JsdocTypeNullable: /* @__PURE__ */ r((t, o) => ({\n        type: \"NULLABLE\",\n        value: o(t.element),\n        meta: {\n          syntax: t.meta.position === \"prefix\" ? \"PREFIX_QUESTION_MARK\" : \"SUFFIX_QUESTION_MARK\"\n        }\n      }), \"JsdocTypeNullable\"),\n      JsdocTypeNotNullable: /* @__PURE__ */ r((t, o) => ({\n        type: \"NOT_NULLABLE\",\n        value: o(t.element),\n        meta: {\n          syntax: t.meta.position === \"prefix\" ? \"PREFIX_BANG\" : \"SUFFIX_BANG\"\n        }\n      }), \"JsdocTypeNotNullable\"),\n      JsdocTypeVariadic: /* @__PURE__ */ r((t, o) => {\n        let i = {\n          type: \"VARIADIC\",\n          meta: {\n            syntax: t.meta.position === \"prefix\" ? \"PREFIX_DOTS\" : t.meta.position === \"suffix\" ? \"SUFFIX_DOTS\" : \"ONLY_DOTS\"\n          }\n        };\n        return t.element !== void 0 && (i.value = o(t.element)), i;\n      }, \"JsdocTypeVariadic\"),\n      JsdocTypeName: /* @__PURE__ */ r((t) => ({\n        type: \"NAME\",\n        name: t.value\n      }), \"JsdocTypeName\"),\n      JsdocTypeTypeof: /* @__PURE__ */ r((t, o) => ({\n        type: \"TYPE_QUERY\",\n        name: o(t.element)\n      }), \"JsdocTypeTypeof\"),\n      JsdocTypeTuple: /* @__PURE__ */ r((t, o) => ({\n        type: \"TUPLE\",\n        entries: t.elements.map(o)\n      }), \"JsdocTypeTuple\"),\n      JsdocTypeKeyof: /* @__PURE__ */ r((t, o) => ({\n        type: \"KEY_QUERY\",\n        value: o(t.element)\n      }), \"JsdocTypeKeyof\"),\n      JsdocTypeImport: /* @__PURE__ */ r((t) => ({\n        type: \"IMPORT\",\n        path: {\n          type: \"STRING_VALUE\",\n          quoteStyle: W(t.element.meta.quote),\n          string: t.element.value\n        }\n      }), \"JsdocTypeImport\"),\n      JsdocTypeUndefined: /* @__PURE__ */ r(() => ({\n        type: \"NAME\",\n        name: \"undefined\"\n      }), \"JsdocTypeUndefined\"),\n      JsdocTypeAny: /* @__PURE__ */ r(() => ({\n        type: \"ANY\"\n      }), \"JsdocTypeAny\"),\n      JsdocTypeFunction: /* @__PURE__ */ r((t, o) => {\n        let i = nr(t), u = {\n          type: t.arrow ? \"ARROW\" : \"FUNCTION\",\n          params: i.params.map((f) => {\n            if (f.type === \"JsdocTypeKeyValue\") {\n              if (f.right === void 0)\n                throw new Error(\"Function parameter without ':' is not expected to be 'KEY_VALUE'\");\n              return {\n                type: \"NAMED_PARAMETER\",\n                name: f.key,\n                typeName: o(f.right)\n              };\n            } else\n              return o(f);\n          }),\n          new: null,\n          returns: null\n        };\n        return i.this !== void 0 ? u.this = o(i.this) : t.arrow || (u.this = null), i.new !== void 0 && (u.new = o(i.new)), t.returnType !==\n        void 0 && (u.returns = o(t.returnType)), u;\n      }, \"JsdocTypeFunction\"),\n      JsdocTypeGeneric: /* @__PURE__ */ r((t, o) => {\n        let i = {\n          type: \"GENERIC\",\n          subject: o(t.left),\n          objects: t.elements.map(o),\n          meta: {\n            syntax: t.meta.brackets === \"square\" ? \"SQUARE_BRACKET\" : t.meta.dot ? \"ANGLE_BRACKET_WITH_DOT\" : \"ANGLE_BRACKET\"\n          }\n        };\n        return t.meta.brackets === \"square\" && t.elements[0].type === \"JsdocTypeFunction\" && !t.elements[0].parenthesis && (i.objects[0] = {\n          type: \"NAME\",\n          name: \"function\"\n        }), i;\n      }, \"JsdocTypeGeneric\"),\n      JsdocTypeObjectField: /* @__PURE__ */ r((t, o) => {\n        if (typeof t.key != \"string\")\n          throw new Error(\"Index signatures and mapped types are not supported\");\n        if (t.right === void 0)\n          return {\n            type: \"RECORD_ENTRY\",\n            key: t.key,\n            quoteStyle: W(t.meta.quote),\n            value: null,\n            readonly: !1\n          };\n        let i = o(t.right);\n        return t.optional && (i = {\n          type: \"OPTIONAL\",\n          value: i,\n          meta: {\n            syntax: \"SUFFIX_KEY_QUESTION_MARK\"\n          }\n        }), {\n          type: \"RECORD_ENTRY\",\n          key: t.key.toString(),\n          quoteStyle: W(t.meta.quote),\n          value: i,\n          readonly: !1\n        };\n      }, \"JsdocTypeObjectField\"),\n      JsdocTypeJsdocObjectField: /* @__PURE__ */ r(() => {\n        throw new Error(\"Keys may not be typed in jsdoctypeparser.\");\n      }, \"JsdocTypeJsdocObjectField\"),\n      JsdocTypeKeyValue: /* @__PURE__ */ r((t, o) => {\n        if (t.right === void 0)\n          return {\n            type: \"RECORD_ENTRY\",\n            key: t.key,\n            quoteStyle: \"none\",\n            value: null,\n            readonly: !1\n          };\n        let i = o(t.right);\n        return t.optional && (i = {\n          type: \"OPTIONAL\",\n          value: i,\n          meta: {\n            syntax: \"SUFFIX_KEY_QUESTION_MARK\"\n          }\n        }), {\n          type: \"RECORD_ENTRY\",\n          key: t.key,\n          quoteStyle: \"none\",\n          value: i,\n          readonly: !1\n        };\n      }, \"JsdocTypeKeyValue\"),\n      JsdocTypeObject: /* @__PURE__ */ r((t, o) => {\n        let i = [];\n        for (let u of t.elements)\n          (u.type === \"JsdocTypeObjectField\" || u.type === \"JsdocTypeJsdocObjectField\") && i.push(o(u));\n        return {\n          type: \"RECORD\",\n          entries: i\n        };\n      }, \"JsdocTypeObject\"),\n      JsdocTypeSpecialNamePath: /* @__PURE__ */ r((t) => {\n        if (t.specialType !== \"module\")\n          throw new Error(`jsdoctypeparser does not support type ${t.specialType} at this point.`);\n        return {\n          type: \"MODULE\",\n          value: {\n            type: \"FILE_PATH\",\n            quoteStyle: W(t.meta.quote),\n            path: t.value\n          }\n        };\n      }, \"JsdocTypeSpecialNamePath\"),\n      JsdocTypeNamePath: /* @__PURE__ */ r((t, o) => {\n        let i = !1, u, f;\n        t.right.type === \"JsdocTypeSpecialNamePath\" && t.right.specialType === \"event\" ? (i = !0, u = t.right.value, f = W(t.right.meta.quote)) :\n        (u = t.right.value, f = W(t.right.meta.quote));\n        let T = {\n          type: Bs(t.pathType),\n          owner: o(t.left),\n          name: u,\n          quoteStyle: f,\n          hasEventPrefix: i\n        };\n        if (T.owner.type === \"MODULE\") {\n          let x = T.owner;\n          return T.owner = T.owner.value, x.value = T, x;\n        } else\n          return T;\n      }, \"JsdocTypeNamePath\"),\n      JsdocTypeUnion: /* @__PURE__ */ r((t, o) => ut(\"UNION\", t.elements.map(o)), \"JsdocTypeUnion\"),\n      JsdocTypeParenthesis: /* @__PURE__ */ r((t, o) => ({\n        type: \"PARENTHESIS\",\n        value: o(w(t.element))\n      }), \"JsdocTypeParenthesis\"),\n      JsdocTypeNull: /* @__PURE__ */ r(() => ({\n        type: \"NAME\",\n        name: \"null\"\n      }), \"JsdocTypeNull\"),\n      JsdocTypeUnknown: /* @__PURE__ */ r(() => ({\n        type: \"UNKNOWN\"\n      }), \"JsdocTypeUnknown\"),\n      JsdocTypeStringValue: /* @__PURE__ */ r((t) => ({\n        type: \"STRING_VALUE\",\n        quoteStyle: W(t.meta.quote),\n        string: t.value\n      }), \"JsdocTypeStringValue\"),\n      JsdocTypeIntersection: /* @__PURE__ */ r((t, o) => ut(\"INTERSECTION\", t.elements.map(o)), \"JsdocTypeIntersection\"),\n      JsdocTypeNumber: /* @__PURE__ */ r((t) => ({\n        type: \"NUMBER_VALUE\",\n        number: t.value.toString()\n      }), \"JsdocTypeNumber\"),\n      JsdocTypeSymbol: I,\n      JsdocTypeProperty: I,\n      JsdocTypePredicate: I,\n      JsdocTypeMappedType: I,\n      JsdocTypeIndexSignature: I\n    };\n    function Gs(t) {\n      return Te($s, t);\n    }\n    r(Gs, \"jtpTransform\");\n    function Ys() {\n      return {\n        JsdocTypeIntersection: /* @__PURE__ */ r((t, o) => ({\n          type: \"JsdocTypeIntersection\",\n          elements: t.elements.map(o)\n        }), \"JsdocTypeIntersection\"),\n        JsdocTypeGeneric: /* @__PURE__ */ r((t, o) => ({\n          type: \"JsdocTypeGeneric\",\n          left: o(t.left),\n          elements: t.elements.map(o),\n          meta: {\n            dot: t.meta.dot,\n            brackets: t.meta.brackets\n          }\n        }), \"JsdocTypeGeneric\"),\n        JsdocTypeNullable: /* @__PURE__ */ r((t) => t, \"JsdocTypeNullable\"),\n        JsdocTypeUnion: /* @__PURE__ */ r((t, o) => ({\n          type: \"JsdocTypeUnion\",\n          elements: t.elements.map(o)\n        }), \"JsdocTypeUnion\"),\n        JsdocTypeUnknown: /* @__PURE__ */ r((t) => t, \"JsdocTypeUnknown\"),\n        JsdocTypeUndefined: /* @__PURE__ */ r((t) => t, \"JsdocTypeUndefined\"),\n        JsdocTypeTypeof: /* @__PURE__ */ r((t, o) => ({\n          type: \"JsdocTypeTypeof\",\n          element: o(t.element)\n        }), \"JsdocTypeTypeof\"),\n        JsdocTypeSymbol: /* @__PURE__ */ r((t, o) => {\n          let i = {\n            type: \"JsdocTypeSymbol\",\n            value: t.value\n          };\n          return t.element !== void 0 && (i.element = o(t.element)), i;\n        }, \"JsdocTypeSymbol\"),\n        JsdocTypeOptional: /* @__PURE__ */ r((t, o) => ({\n          type: \"JsdocTypeOptional\",\n          element: o(t.element),\n          meta: {\n            position: t.meta.position\n          }\n        }), \"JsdocTypeOptional\"),\n        JsdocTypeObject: /* @__PURE__ */ r((t, o) => ({\n          type: \"JsdocTypeObject\",\n          meta: {\n            separator: \"comma\"\n          },\n          elements: t.elements.map(o)\n        }), \"JsdocTypeObject\"),\n        JsdocTypeNumber: /* @__PURE__ */ r((t) => t, \"JsdocTypeNumber\"),\n        JsdocTypeNull: /* @__PURE__ */ r((t) => t, \"JsdocTypeNull\"),\n        JsdocTypeNotNullable: /* @__PURE__ */ r((t, o) => ({\n          type: \"JsdocTypeNotNullable\",\n          element: o(t.element),\n          meta: {\n            position: t.meta.position\n          }\n        }), \"JsdocTypeNotNullable\"),\n        JsdocTypeSpecialNamePath: /* @__PURE__ */ r((t) => t, \"JsdocTypeSpecialNamePath\"),\n        JsdocTypeObjectField: /* @__PURE__ */ r((t, o) => ({\n          type: \"JsdocTypeObjectField\",\n          key: t.key,\n          right: t.right === void 0 ? void 0 : o(t.right),\n          optional: t.optional,\n          readonly: t.readonly,\n          meta: t.meta\n        }), \"JsdocTypeObjectField\"),\n        JsdocTypeJsdocObjectField: /* @__PURE__ */ r((t, o) => ({\n          type: \"JsdocTypeJsdocObjectField\",\n          left: o(t.left),\n          right: o(t.right)\n        }), \"JsdocTypeJsdocObjectField\"),\n        JsdocTypeKeyValue: /* @__PURE__ */ r((t, o) => ({\n          type: \"JsdocTypeKeyValue\",\n          key: t.key,\n          right: t.right === void 0 ? void 0 : o(t.right),\n          optional: t.optional,\n          variadic: t.variadic\n        }), \"JsdocTypeKeyValue\"),\n        JsdocTypeImport: /* @__PURE__ */ r((t, o) => ({\n          type: \"JsdocTypeImport\",\n          element: o(t.element)\n        }), \"JsdocTypeImport\"),\n        JsdocTypeAny: /* @__PURE__ */ r((t) => t, \"JsdocTypeAny\"),\n        JsdocTypeStringValue: /* @__PURE__ */ r((t) => t, \"JsdocTypeStringValue\"),\n        JsdocTypeNamePath: /* @__PURE__ */ r((t) => t, \"JsdocTypeNamePath\"),\n        JsdocTypeVariadic: /* @__PURE__ */ r((t, o) => {\n          let i = {\n            type: \"JsdocTypeVariadic\",\n            meta: {\n              position: t.meta.position,\n              squareBrackets: t.meta.squareBrackets\n            }\n          };\n          return t.element !== void 0 && (i.element = o(t.element)), i;\n        }, \"JsdocTypeVariadic\"),\n        JsdocTypeTuple: /* @__PURE__ */ r((t, o) => ({\n          type: \"JsdocTypeTuple\",\n          elements: t.elements.map(o)\n        }), \"JsdocTypeTuple\"),\n        JsdocTypeName: /* @__PURE__ */ r((t) => t, \"JsdocTypeName\"),\n        JsdocTypeFunction: /* @__PURE__ */ r((t, o) => {\n          let i = {\n            type: \"JsdocTypeFunction\",\n            arrow: t.arrow,\n            parameters: t.parameters.map(o),\n            constructor: t.constructor,\n            parenthesis: t.parenthesis\n          };\n          return t.returnType !== void 0 && (i.returnType = o(t.returnType)), i;\n        }, \"JsdocTypeFunction\"),\n        JsdocTypeKeyof: /* @__PURE__ */ r((t, o) => ({\n          type: \"JsdocTypeKeyof\",\n          element: o(t.element)\n        }), \"JsdocTypeKeyof\"),\n        JsdocTypeParenthesis: /* @__PURE__ */ r((t, o) => ({\n          type: \"JsdocTypeParenthesis\",\n          element: o(t.element)\n        }), \"JsdocTypeParenthesis\"),\n        JsdocTypeProperty: /* @__PURE__ */ r((t) => t, \"JsdocTypeProperty\"),\n        JsdocTypePredicate: /* @__PURE__ */ r((t, o) => ({\n          type: \"JsdocTypePredicate\",\n          left: o(t.left),\n          right: o(t.right)\n        }), \"JsdocTypePredicate\"),\n        JsdocTypeIndexSignature: /* @__PURE__ */ r((t, o) => ({\n          type: \"JsdocTypeIndexSignature\",\n          key: t.key,\n          right: o(t.right)\n        }), \"JsdocTypeIndexSignature\"),\n        JsdocTypeMappedType: /* @__PURE__ */ r((t, o) => ({\n          type: \"JsdocTypeMappedType\",\n          key: t.key,\n          right: o(t.right)\n        }), \"JsdocTypeMappedType\")\n      };\n    }\n    r(Ys, \"identityTransformRules\");\n    let ar = {\n      JsdocTypeAny: [],\n      JsdocTypeFunction: [\"parameters\", \"returnType\"],\n      JsdocTypeGeneric: [\"left\", \"elements\"],\n      JsdocTypeImport: [],\n      JsdocTypeIndexSignature: [\"right\"],\n      JsdocTypeIntersection: [\"elements\"],\n      JsdocTypeKeyof: [\"element\"],\n      JsdocTypeKeyValue: [\"right\"],\n      JsdocTypeMappedType: [\"right\"],\n      JsdocTypeName: [],\n      JsdocTypeNamePath: [\"left\", \"right\"],\n      JsdocTypeNotNullable: [\"element\"],\n      JsdocTypeNull: [],\n      JsdocTypeNullable: [\"element\"],\n      JsdocTypeNumber: [],\n      JsdocTypeObject: [\"elements\"],\n      JsdocTypeObjectField: [\"right\"],\n      JsdocTypeJsdocObjectField: [\"left\", \"right\"],\n      JsdocTypeOptional: [\"element\"],\n      JsdocTypeParenthesis: [\"element\"],\n      JsdocTypeSpecialNamePath: [],\n      JsdocTypeStringValue: [],\n      JsdocTypeSymbol: [\"element\"],\n      JsdocTypeTuple: [\"elements\"],\n      JsdocTypeTypeof: [\"element\"],\n      JsdocTypeUndefined: [],\n      JsdocTypeUnion: [\"elements\"],\n      JsdocTypeUnknown: [],\n      JsdocTypeVariadic: [\"element\"],\n      JsdocTypeProperty: [],\n      JsdocTypePredicate: [\"left\", \"right\"]\n    };\n    function lt(t, o, i, u, f) {\n      u?.(t, o, i);\n      let T = ar[t.type];\n      for (let x of T) {\n        let S = t[x];\n        if (S !== void 0)\n          if (Array.isArray(S))\n            for (let D of S)\n              lt(D, t, x, u, f);\n          else\n            lt(S, t, x, u, f);\n      }\n      f?.(t, o, i);\n    }\n    r(lt, \"_traverse\");\n    function Hs(t, o, i) {\n      lt(t, void 0, void 0, o, i);\n    }\n    r(Hs, \"traverse\"), e.catharsisTransform = Ks, e.identityTransformRules = Ys, e.jtpTransform = Gs, e.parse = rr, e.stringify = Us, e.stringifyRules =\n    or, e.transform = Te, e.traverse = Hs, e.tryParse = ks, e.visitorKeys = ar;\n  });\n});\n\n// src/docs-tools/argTypes/convert/typescript/convert.ts\nimport { UnknownArgTypesError as np } from \"@storybook/core/preview-errors\";\n\n// src/docs-tools/argTypes/convert/utils.ts\nvar cr = /^['\"]|['\"]$/g, tp = /* @__PURE__ */ r((e) => e.replace(cr, \"\"), \"trimQuotes\"), rp = /* @__PURE__ */ r((e) => cr.test(e), \"includes\\\nQuotes\"), ke = /* @__PURE__ */ r((e) => {\n  let n = tp(e);\n  return rp(e) || Number.isNaN(Number(n)) ? n : Number(n);\n}, \"parseLiteral\");\n\n// src/docs-tools/argTypes/convert/typescript/convert.ts\nvar op = /* @__PURE__ */ r((e) => {\n  switch (e.type) {\n    case \"function\":\n      return { name: \"function\" };\n    case \"object\":\n      let n = {};\n      return e.signature.properties.forEach((a) => {\n        n[a.key] = te(a.value);\n      }), {\n        name: \"object\",\n        value: n\n      };\n    default:\n      throw new np({ type: e, language: \"Typescript\" });\n  }\n}, \"convertSig\"), te = /* @__PURE__ */ r((e) => {\n  let { name: n, raw: a } = e, s = {};\n  switch (typeof a < \"u\" && (s.raw = a), e.name) {\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n    case \"boolean\":\n      return { ...s, name: n };\n    case \"Array\":\n      return { ...s, name: \"array\", value: e.elements.map(te) };\n    case \"signature\":\n      return { ...s, ...op(e) };\n    case \"union\":\n      let p;\n      return e.elements?.every((c) => c.name === \"literal\") ? p = {\n        ...s,\n        name: \"enum\",\n        // @ts-expect-error fix types\n        value: e.elements?.map((c) => ke(c.value))\n      } : p = { ...s, name: n, value: e.elements?.map(te) }, p;\n    case \"intersection\":\n      return { ...s, name: n, value: e.elements?.map(te) };\n    default:\n      return { ...s, name: \"other\", value: n };\n  }\n}, \"convert\");\n\n// src/docs-tools/argTypes/convert/flow/convert.ts\nimport { UnknownArgTypesError as ap } from \"@storybook/core/preview-errors\";\nvar ip = /* @__PURE__ */ r((e) => e.name === \"literal\", \"isLiteral\"), sp = /* @__PURE__ */ r((e) => e.value.replace(/['|\"]/g, \"\"), \"toEnumOp\\\ntion\"), pp = /* @__PURE__ */ r((e) => {\n  switch (e.type) {\n    case \"function\":\n      return { name: \"function\" };\n    case \"object\":\n      let n = {};\n      return e.signature.properties.forEach((a) => {\n        n[a.key] = re(a.value);\n      }), {\n        name: \"object\",\n        value: n\n      };\n    default:\n      throw new ap({ type: e, language: \"Flow\" });\n  }\n}, \"convertSig\"), re = /* @__PURE__ */ r((e) => {\n  let { name: n, raw: a } = e, s = {};\n  switch (typeof a < \"u\" && (s.raw = a), e.name) {\n    case \"literal\":\n      return { ...s, name: \"other\", value: e.value };\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n    case \"boolean\":\n      return { ...s, name: n };\n    case \"Array\":\n      return { ...s, name: \"array\", value: e.elements.map(re) };\n    case \"signature\":\n      return { ...s, ...pp(e) };\n    case \"union\":\n      return e.elements?.every(ip) ? { ...s, name: \"enum\", value: e.elements?.map(sp) } : { ...s, name: n, value: e.elements?.map(re) };\n    case \"intersection\":\n      return { ...s, name: n, value: e.elements?.map(re) };\n    default:\n      return { ...s, name: \"other\", value: n };\n  }\n}, \"convert\");\n\n// src/docs-tools/argTypes/convert/proptypes/convert.ts\nvar Mi = pr(Ui(), 1);\nvar wm = /^\\(.*\\) => /, fe = /* @__PURE__ */ r((e) => {\n  let { name: n, raw: a, computed: s, value: p } = e, c = {};\n  switch (typeof a < \"u\" && (c.raw = a), n) {\n    case \"enum\": {\n      let d = s ? p : p.map((m) => ke(m.value));\n      return { ...c, name: n, value: d };\n    }\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n      return { ...c, name: n };\n    case \"func\":\n      return { ...c, name: \"function\" };\n    case \"bool\":\n    case \"boolean\":\n      return { ...c, name: \"boolean\" };\n    case \"arrayOf\":\n    case \"array\":\n      return { ...c, name: \"array\", value: p && fe(p) };\n    case \"object\":\n      return { ...c, name: n };\n    case \"objectOf\":\n      return { ...c, name: n, value: fe(p) };\n    case \"shape\":\n    case \"exact\":\n      let y = (0, Mi.default)(p, (d) => fe(d));\n      return { ...c, name: \"object\", value: y };\n    case \"union\":\n      return { ...c, name: \"union\", value: p.map((d) => fe(d)) };\n    case \"instanceOf\":\n    case \"element\":\n    case \"elementType\":\n    default: {\n      if (n?.indexOf(\"|\") > 0)\n        try {\n          let g = n.split(\"|\").map((b) => JSON.parse(b));\n          return { ...c, name: \"enum\", value: g };\n        } catch {\n        }\n      let d = p ? `${n}(${p})` : n, m = wm.test(n) ? \"function\" : \"other\";\n      return { ...c, name: m, value: d };\n    }\n  }\n}, \"convert\");\n\n// src/docs-tools/argTypes/convert/index.ts\nvar He = /* @__PURE__ */ r((e) => {\n  let { type: n, tsType: a, flowType: s } = e;\n  try {\n    if (n != null) return fe(n);\n    if (a != null) return te(a);\n    if (s != null) return re(s);\n  } catch (p) {\n    console.error(p);\n  }\n  return null;\n}, \"convert\");\n\n// src/docs-tools/argTypes/docgen/types.ts\nvar Pm = /* @__PURE__ */ ((p) => (p.JAVASCRIPT = \"JavaScript\", p.FLOW = \"Flow\", p.TYPESCRIPT = \"TypeScript\", p.UNKNOWN = \"Unknown\", p))(Pm ||\n{});\n\n// src/docs-tools/argTypes/docgen/utils/defaultValue.ts\nvar Jm = [\"null\", \"undefined\"];\nfunction ye(e) {\n  return Jm.some((n) => n === e);\n}\nr(ye, \"isDefaultValueBlacklisted\");\n\n// src/docs-tools/argTypes/docgen/utils/string.ts\nvar Vi = /* @__PURE__ */ r((e) => {\n  if (!e)\n    return \"\";\n  if (typeof e == \"string\")\n    return e;\n  throw new Error(`Description: expected string, got: ${JSON.stringify(e)}`);\n}, \"str\");\n\n// src/docs-tools/argTypes/docgen/utils/docgenInfo.ts\nfunction Ki(e) {\n  return !!e.__docgenInfo;\n}\nr(Ki, \"hasDocgen\");\nfunction Bi(e) {\n  return e != null && Object.keys(e).length > 0;\n}\nr(Bi, \"isValidDocgenSection\");\nfunction $i(e, n) {\n  return Ki(e) ? e.__docgenInfo[n] : null;\n}\nr($i, \"getDocgenSection\");\nfunction Gi(e) {\n  return Ki(e) ? Vi(e.__docgenInfo.description) : \"\";\n}\nr(Gi, \"getDocgenDescription\");\n\n// ../node_modules/comment-parser/es6/primitives.js\nvar F;\n(function(e) {\n  e.start = \"/**\", e.nostart = \"/***\", e.delim = \"*\", e.end = \"*/\";\n})(F = F || (F = {}));\n\n// ../node_modules/comment-parser/es6/util.js\nfunction Ct(e) {\n  return /^\\s+$/.test(e);\n}\nr(Ct, \"isSpace\");\nfunction Yi(e) {\n  let n = e.match(/\\r+$/);\n  return n == null ? [\"\", e] : [e.slice(-n[0].length), e.slice(0, -n[0].length)];\n}\nr(Yi, \"splitCR\");\nfunction V(e) {\n  let n = e.match(/^\\s+/);\n  return n == null ? [\"\", e] : [e.slice(0, n[0].length), e.slice(n[0].length)];\n}\nr(V, \"splitSpace\");\nfunction Hi(e) {\n  return e.split(/\\n/);\n}\nr(Hi, \"splitLines\");\nfunction zi(e = {}) {\n  return Object.assign({ tag: \"\", name: \"\", type: \"\", optional: !1, description: \"\", problems: [], source: [] }, e);\n}\nr(zi, \"seedSpec\");\nfunction Ut(e = {}) {\n  return Object.assign({ start: \"\", delimiter: \"\", postDelimiter: \"\", tag: \"\", postTag: \"\", name: \"\", postName: \"\", type: \"\", postType: \"\", description: \"\",\n  end: \"\", lineEnd: \"\" }, e);\n}\nr(Ut, \"seedTokens\");\n\n// ../node_modules/comment-parser/es6/parser/block-parser.js\nvar Sm = /^@\\S+/;\nfunction Mt({ fence: e = \"```\" } = {}) {\n  let n = Em(e), a = /* @__PURE__ */ r((s, p) => n(s) ? !p : p, \"toggleFence\");\n  return /* @__PURE__ */ r(function(p) {\n    let c = [[]], y = !1;\n    for (let d of p)\n      Sm.test(d.tokens.description) && !y ? c.push([d]) : c[c.length - 1].push(d), y = a(d.tokens.description, y);\n    return c;\n  }, \"parseBlock\");\n}\nr(Mt, \"getParser\");\nfunction Em(e) {\n  return typeof e == \"string\" ? (n) => n.split(e).length % 2 === 0 : e;\n}\nr(Em, \"getFencer\");\n\n// ../node_modules/comment-parser/es6/parser/source-parser.js\nfunction Vt({ startLine: e = 0, markers: n = F } = {}) {\n  let a = null, s = e;\n  return /* @__PURE__ */ r(function(c) {\n    let y = c, d = Ut();\n    if ([d.lineEnd, y] = Yi(y), [d.start, y] = V(y), a === null && y.startsWith(n.start) && !y.startsWith(n.nostart) && (a = [], d.delimiter =\n    y.slice(0, n.start.length), y = y.slice(n.start.length), [d.postDelimiter, y] = V(y)), a === null)\n      return s++, null;\n    let m = y.trimRight().endsWith(n.end);\n    if (d.delimiter === \"\" && y.startsWith(n.delim) && !y.startsWith(n.end) && (d.delimiter = n.delim, y = y.slice(n.delim.length), [d.postDelimiter,\n    y] = V(y)), m) {\n      let g = y.trimRight();\n      d.end = y.slice(g.length - n.end.length), y = g.slice(0, -n.end.length);\n    }\n    if (d.description = y, a.push({ number: s, source: c, tokens: d }), s++, m) {\n      let g = a.slice();\n      return a = null, g;\n    }\n    return null;\n  }, \"parseSource\");\n}\nr(Vt, \"getParser\");\n\n// ../node_modules/comment-parser/es6/parser/spec-parser.js\nfunction Kt({ tokenizers: e }) {\n  return /* @__PURE__ */ r(function(a) {\n    var s;\n    let p = zi({ source: a });\n    for (let c of e)\n      if (p = c(p), !((s = p.problems[p.problems.length - 1]) === null || s === void 0) && s.critical)\n        break;\n    return p;\n  }, \"parseSpec\");\n}\nr(Kt, \"getParser\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/tag.js\nfunction ze() {\n  return (e) => {\n    let { tokens: n } = e.source[0], a = n.description.match(/\\s*(@(\\S+))(\\s*)/);\n    return a === null ? (e.problems.push({\n      code: \"spec:tag:prefix\",\n      message: 'tag should start with \"@\" symbol',\n      line: e.source[0].number,\n      critical: !0\n    }), e) : (n.tag = a[1], n.postTag = a[3], n.description = n.description.slice(a[0].length), e.tag = a[2], e);\n  };\n}\nr(ze, \"tagTokenizer\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/type.js\nfunction We(e = \"compact\") {\n  let n = Am(e);\n  return (a) => {\n    let s = 0, p = [];\n    for (let [d, { tokens: m }] of a.source.entries()) {\n      let g = \"\";\n      if (d === 0 && m.description[0] !== \"{\")\n        return a;\n      for (let b of m.description)\n        if (b === \"{\" && s++, b === \"}\" && s--, g += b, s === 0)\n          break;\n      if (p.push([m, g]), s === 0)\n        break;\n    }\n    if (s !== 0)\n      return a.problems.push({\n        code: \"spec:type:unpaired-curlies\",\n        message: \"unpaired curlies\",\n        line: a.source[0].number,\n        critical: !0\n      }), a;\n    let c = [], y = p[0][0].postDelimiter.length;\n    for (let [d, [m, g]] of p.entries())\n      m.type = g, d > 0 && (m.type = m.postDelimiter.slice(y) + g, m.postDelimiter = m.postDelimiter.slice(0, y)), [m.postType, m.description] =\n      V(m.description.slice(g.length)), c.push(m.type);\n    return c[0] = c[0].slice(1), c[c.length - 1] = c[c.length - 1].slice(0, -1), a.type = n(c), a;\n  };\n}\nr(We, \"typeTokenizer\");\nvar Om = /* @__PURE__ */ r((e) => e.trim(), \"trim\");\nfunction Am(e) {\n  return e === \"compact\" ? (n) => n.map(Om).join(\"\") : e === \"preserve\" ? (n) => n.join(`\n`) : e;\n}\nr(Am, \"getJoiner\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/name.js\nvar Nm = /* @__PURE__ */ r((e) => e && e.startsWith('\"') && e.endsWith('\"'), \"isQuoted\");\nfunction Xe() {\n  let e = /* @__PURE__ */ r((n, { tokens: a }, s) => a.type === \"\" ? n : s, \"typeEnd\");\n  return (n) => {\n    let { tokens: a } = n.source[n.source.reduce(e, 0)], s = a.description.trimLeft(), p = s.split('\"');\n    if (p.length > 1 && p[0] === \"\" && p.length % 2 === 1)\n      return n.name = p[1], a.name = `\"${p[1]}\"`, [a.postName, a.description] = V(s.slice(a.name.length)), n;\n    let c = 0, y = \"\", d = !1, m;\n    for (let b of s) {\n      if (c === 0 && Ct(b))\n        break;\n      b === \"[\" && c++, b === \"]\" && c--, y += b;\n    }\n    if (c !== 0)\n      return n.problems.push({\n        code: \"spec:name:unpaired-brackets\",\n        message: \"unpaired brackets\",\n        line: n.source[0].number,\n        critical: !0\n      }), n;\n    let g = y;\n    if (y[0] === \"[\" && y[y.length - 1] === \"]\") {\n      d = !0, y = y.slice(1, -1);\n      let b = y.split(\"=\");\n      if (y = b[0].trim(), b[1] !== void 0 && (m = b.slice(1).join(\"=\").trim()), y === \"\")\n        return n.problems.push({\n          code: \"spec:name:empty-name\",\n          message: \"empty name\",\n          line: n.source[0].number,\n          critical: !0\n        }), n;\n      if (m === \"\")\n        return n.problems.push({\n          code: \"spec:name:empty-default\",\n          message: \"empty default value\",\n          line: n.source[0].number,\n          critical: !0\n        }), n;\n      if (!Nm(m) && /=(?!>)/.test(m))\n        return n.problems.push({\n          code: \"spec:name:invalid-default\",\n          message: \"invalid default value syntax\",\n          line: n.source[0].number,\n          critical: !0\n        }), n;\n    }\n    return n.optional = d, n.name = y, a.name = g, m !== void 0 && (n.default = m), [a.postName, a.description] = V(s.slice(a.name.length)),\n    n;\n  };\n}\nr(Xe, \"nameTokenizer\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/description.js\nfunction Qe(e = \"compact\", n = F) {\n  let a = Bt(e);\n  return (s) => (s.description = a(s.source, n), s);\n}\nr(Qe, \"descriptionTokenizer\");\nfunction Bt(e) {\n  return e === \"compact\" ? _m : e === \"preserve\" ? Im : e;\n}\nr(Bt, \"getJoiner\");\nfunction _m(e, n = F) {\n  return e.map(({ tokens: { description: a } }) => a.trim()).filter((a) => a !== \"\").join(\" \");\n}\nr(_m, \"compactJoiner\");\nvar Dm = /* @__PURE__ */ r((e, { tokens: n }, a) => n.type === \"\" ? e : a, \"lineNo\"), qm = /* @__PURE__ */ r(({ tokens: e }) => (e.delimiter ===\n\"\" ? e.start : e.postDelimiter.slice(1)) + e.description, \"getDescription\");\nfunction Im(e, n = F) {\n  if (e.length === 0)\n    return \"\";\n  e[0].tokens.description === \"\" && e[0].tokens.delimiter === n.start && (e = e.slice(1));\n  let a = e[e.length - 1];\n  return a !== void 0 && a.tokens.description === \"\" && a.tokens.end.endsWith(n.end) && (e = e.slice(0, -1)), e = e.slice(e.reduce(Dm, 0)), e.\n  map(qm).join(`\n`);\n}\nr(Im, \"preserveJoiner\");\n\n// ../node_modules/comment-parser/es6/parser/index.js\nfunction $t({ startLine: e = 0, fence: n = \"```\", spacing: a = \"compact\", markers: s = F, tokenizers: p = [\n  ze(),\n  We(a),\n  Xe(),\n  Qe(a)\n] } = {}) {\n  if (e < 0 || e % 1 > 0)\n    throw new Error(\"Invalid startLine\");\n  let c = Vt({ startLine: e, markers: s }), y = Mt({ fence: n }), d = Kt({ tokenizers: p }), m = Bt(a);\n  return function(g) {\n    let b = [];\n    for (let A of Hi(g)) {\n      let J = c(A);\n      if (J === null)\n        continue;\n      let v = y(J), N = v.slice(1).map(d);\n      b.push({\n        description: m(v[0], s),\n        tags: N,\n        source: J,\n        problems: N.reduce((q, R) => q.concat(R.problems), [])\n      });\n    }\n    return b;\n  };\n}\nr($t, \"getParser\");\n\n// ../node_modules/comment-parser/es6/stringifier/index.js\nfunction Rm(e) {\n  return e.start + e.delimiter + e.postDelimiter + e.tag + e.postTag + e.type + e.postType + e.name + e.postName + e.description + e.end + e.\n  lineEnd;\n}\nr(Rm, \"join\");\nfunction Gt() {\n  return (e) => e.source.map(({ tokens: n }) => Rm(n)).join(`\n`);\n}\nr(Gt, \"getStringifier\");\n\n// ../node_modules/comment-parser/es6/stringifier/inspect.js\nvar jm = {\n  line: 0,\n  start: 0,\n  delimiter: 0,\n  postDelimiter: 0,\n  tag: 0,\n  postTag: 0,\n  name: 0,\n  postName: 0,\n  type: 0,\n  postType: 0,\n  description: 0,\n  end: 0,\n  lineEnd: 0\n};\nvar Dv = Object.keys(jm);\n\n// ../node_modules/comment-parser/es6/index.js\nfunction Wi(e, n = {}) {\n  return $t(n)(e);\n}\nr(Wi, \"parse\");\nvar Qv = Gt();\n\n// src/docs-tools/argTypes/jsdocParser.ts\nvar de = pr(Qi(), 1);\nfunction Fm(e) {\n  return e != null && e.includes(\"@\");\n}\nr(Fm, \"containsJsDoc\");\nfunction Lm(e) {\n  let s = `/**\n` + (e ?? \"\").split(`\n`).map((c) => ` * ${c}`).join(`\n`) + `\n*/`, p = Wi(s, {\n    spacing: \"preserve\"\n  });\n  if (!p || p.length === 0)\n    throw new Error(\"Cannot parse JSDoc tags.\");\n  return p[0];\n}\nr(Lm, \"parse\");\nvar km = {\n  tags: [\"param\", \"arg\", \"argument\", \"returns\", \"ignore\", \"deprecated\"]\n}, Zi = /* @__PURE__ */ r((e, n = km) => {\n  if (!Fm(e))\n    return {\n      includesJsDoc: !1,\n      ignore: !1\n    };\n  let a = Lm(e), s = Cm(a, n.tags);\n  return s.ignore ? {\n    includesJsDoc: !0,\n    ignore: !0\n  } : {\n    includesJsDoc: !0,\n    ignore: !1,\n    // Always use the parsed description to ensure JSDoc is removed from the description.\n    description: a.description.trim(),\n    extractedTags: s\n  };\n}, \"parseJsDoc\");\nfunction Cm(e, n) {\n  let a = {\n    params: null,\n    deprecated: null,\n    returns: null,\n    ignore: !1\n  };\n  for (let s of e.tags)\n    if (!(n !== void 0 && !n.includes(s.tag)))\n      if (s.tag === \"ignore\") {\n        a.ignore = !0;\n        break;\n      } else\n        switch (s.tag) {\n          case \"param\":\n          case \"arg\":\n          case \"argument\": {\n            let p = Mm(s);\n            p != null && (a.params == null && (a.params = []), a.params.push(p));\n            break;\n          }\n          case \"deprecated\": {\n            let p = Vm(s);\n            p != null && (a.deprecated = p);\n            break;\n          }\n          case \"returns\": {\n            let p = Km(s);\n            p != null && (a.returns = p);\n            break;\n          }\n          default:\n            break;\n        }\n  return a;\n}\nr(Cm, \"extractJsDocTags\");\nfunction Um(e) {\n  return e.replace(/[\\.-]$/, \"\");\n}\nr(Um, \"normaliseParamName\");\nfunction Mm(e) {\n  if (!e.name || e.name === \"-\")\n    return null;\n  let n = rs(e.type);\n  return {\n    name: e.name,\n    type: n,\n    description: ts(e.description),\n    getPrettyName: /* @__PURE__ */ r(() => Um(e.name), \"getPrettyName\"),\n    getTypeName: /* @__PURE__ */ r(() => n ? ns(n) : null, \"getTypeName\")\n  };\n}\nr(Mm, \"extractParam\");\nfunction Vm(e) {\n  return e.name ? es(e.name, e.description) : null;\n}\nr(Vm, \"extractDeprecated\");\nfunction es(e, n) {\n  let a = e === \"\" ? n : `${e} ${n}`;\n  return ts(a);\n}\nr(es, \"joinNameAndDescription\");\nfunction ts(e) {\n  let n = e.replace(/^- /g, \"\").trim();\n  return n === \"\" ? null : n;\n}\nr(ts, \"normaliseDescription\");\nfunction Km(e) {\n  let n = rs(e.type);\n  return n ? {\n    type: n,\n    description: es(e.name, e.description),\n    getTypeName: /* @__PURE__ */ r(() => ns(n), \"getTypeName\")\n  } : null;\n}\nr(Km, \"extractReturns\");\nvar z = (0, de.stringifyRules)(), Bm = z.JsdocTypeObject;\nz.JsdocTypeAny = () => \"any\";\nz.JsdocTypeObject = (e, n) => `(${Bm(e, n)})`;\nz.JsdocTypeOptional = (e, n) => n(e.element);\nz.JsdocTypeNullable = (e, n) => n(e.element);\nz.JsdocTypeNotNullable = (e, n) => n(e.element);\nz.JsdocTypeUnion = (e, n) => e.elements.map(n).join(\"|\");\nfunction rs(e) {\n  try {\n    return (0, de.parse)(e, \"typescript\");\n  } catch {\n    return null;\n  }\n}\nr(rs, \"extractType\");\nfunction ns(e) {\n  return (0, de.transform)(z, e);\n}\nr(ns, \"extractTypeName\");\n\n// src/docs-tools/argTypes/utils.ts\nvar sw = 90, pw = 50;\nfunction Ht(e) {\n  return e.length > 90;\n}\nr(Ht, \"isTooLongForTypeSummary\");\nfunction os(e) {\n  return e.length > 50;\n}\nr(os, \"isTooLongForDefaultValueSummary\");\nfunction O(e, n) {\n  return e === n ? { summary: e } : { summary: e, detail: n };\n}\nr(O, \"createSummaryValue\");\nvar cw = /* @__PURE__ */ r((e) => e.replace(/\\\\r\\\\n/g, \"\\\\n\"), \"normalizeNewlines\");\n\n// src/docs-tools/argTypes/docgen/flow/createType.ts\nfunction as({ name: e, value: n, elements: a, raw: s }) {\n  return n ?? (a != null ? a.map(as).join(\" | \") : s ?? e);\n}\nr(as, \"generateUnionElement\");\nfunction $m({ name: e, raw: n, elements: a }) {\n  return a != null ? O(a.map(as).join(\" | \")) : n != null ? O(n.replace(/^\\|\\s*/, \"\")) : O(e);\n}\nr($m, \"generateUnion\");\nfunction Gm({ type: e, raw: n }) {\n  return n != null ? O(n) : O(e);\n}\nr(Gm, \"generateFuncSignature\");\nfunction Ym({ type: e, raw: n }) {\n  return n != null ? Ht(n) ? O(e, n) : O(n) : O(e);\n}\nr(Ym, \"generateObjectSignature\");\nfunction Hm(e) {\n  let { type: n } = e;\n  return n === \"object\" ? Ym(e) : Gm(e);\n}\nr(Hm, \"generateSignature\");\nfunction zm({ name: e, raw: n }) {\n  return n != null ? Ht(n) ? O(e, n) : O(n) : O(e);\n}\nr(zm, \"generateDefault\");\nfunction is(e) {\n  if (e == null)\n    return null;\n  switch (e.name) {\n    case \"union\":\n      return $m(e);\n    case \"signature\":\n      return Hm(e);\n    default:\n      return zm(e);\n  }\n}\nr(is, \"createType\");\n\n// src/docs-tools/argTypes/docgen/flow/createDefaultValue.ts\nfunction ss(e, n) {\n  if (e != null) {\n    let { value: a } = e;\n    if (!ye(a))\n      return os(a) ? O(n?.name, a) : O(a);\n  }\n  return null;\n}\nr(ss, \"createDefaultValue\");\n\n// src/docs-tools/argTypes/docgen/flow/createPropDef.ts\nvar ps = /* @__PURE__ */ r((e, n) => {\n  let { flowType: a, description: s, required: p, defaultValue: c } = n;\n  return {\n    name: e,\n    type: is(a),\n    required: p,\n    description: s,\n    defaultValue: ss(c ?? null, a ?? null)\n  };\n}, \"createFlowPropDef\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createType.ts\nfunction cs({ tsType: e, required: n }) {\n  if (e == null)\n    return null;\n  let a = e.name;\n  return n || (a = a.replace(\" | undefined\", \"\")), O(\n    [\"Array\", \"Record\", \"signature\"].includes(e.name) ? e.raw : a\n  );\n}\nr(cs, \"createType\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createDefaultValue.ts\nfunction us({ defaultValue: e }) {\n  if (e != null) {\n    let { value: n } = e;\n    if (!ye(n))\n      return O(n);\n  }\n  return null;\n}\nr(us, \"createDefaultValue\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createPropDef.ts\nvar ls = /* @__PURE__ */ r((e, n) => {\n  let { description: a, required: s } = n;\n  return {\n    name: e,\n    type: cs(n),\n    required: s,\n    description: a,\n    defaultValue: us(n)\n  };\n}, \"createTsPropDef\");\n\n// src/docs-tools/argTypes/docgen/createPropDef.ts\nfunction Wm(e) {\n  return e != null ? O(e.name) : null;\n}\nr(Wm, \"createType\");\nfunction Xm(e) {\n  let { computed: n, func: a } = e;\n  return typeof n > \"u\" && typeof a > \"u\";\n}\nr(Xm, \"isReactDocgenTypescript\");\nfunction Qm(e) {\n  return e ? e.name === \"string\" ? !0 : e.name === \"enum\" ? Array.isArray(e.value) && e.value.every(\n    ({ value: n }) => typeof n == \"string\" && n[0] === '\"' && n[n.length - 1] === '\"'\n  ) : !1 : !1;\n}\nr(Qm, \"isStringValued\");\nfunction Zm(e, n) {\n  if (e != null) {\n    let { value: a } = e;\n    if (!ye(a))\n      return Xm(e) && Qm(n) ? O(JSON.stringify(a)) : O(a);\n  }\n  return null;\n}\nr(Zm, \"createDefaultValue\");\nfunction fs(e, n, a) {\n  let { description: s, required: p, defaultValue: c } = a;\n  return {\n    name: e,\n    type: Wm(n),\n    required: p,\n    description: s,\n    defaultValue: Zm(c, n)\n  };\n}\nr(fs, \"createBasicPropDef\");\nfunction et(e, n) {\n  if (n?.includesJsDoc) {\n    let { description: a, extractedTags: s } = n;\n    a != null && (e.description = n.description);\n    let p = {\n      ...s,\n      params: s?.params?.map(\n        (c) => ({\n          name: c.getPrettyName(),\n          description: c.description\n        })\n      )\n    };\n    Object.values(p).filter(Boolean).length > 0 && (e.jsDocTags = p);\n  }\n  return e;\n}\nr(et, \"applyJsDocResult\");\nvar eT = /* @__PURE__ */ r((e, n, a) => {\n  let s = fs(e, n.type, n);\n  return s.sbType = He(n), et(s, a);\n}, \"javaScriptFactory\"), tT = /* @__PURE__ */ r((e, n, a) => {\n  let s = ls(e, n);\n  return s.sbType = He(n), et(s, a);\n}, \"tsFactory\"), rT = /* @__PURE__ */ r((e, n, a) => {\n  let s = ps(e, n);\n  return s.sbType = He(n), et(s, a);\n}, \"flowFactory\"), nT = /* @__PURE__ */ r((e, n, a) => {\n  let s = fs(e, { name: \"unknown\" }, n);\n  return et(s, a);\n}, \"unknownFactory\"), zt = /* @__PURE__ */ r((e) => {\n  switch (e) {\n    case \"JavaScript\":\n      return eT;\n    case \"TypeScript\":\n      return tT;\n    case \"Flow\":\n      return rT;\n    default:\n      return nT;\n  }\n}, \"getPropDefFactory\");\n\n// src/docs-tools/argTypes/docgen/extractDocgenProps.ts\nvar ys = /* @__PURE__ */ r((e) => e.type != null ? \"JavaScript\" : e.flowType != null ? \"Flow\" : e.tsType != null ? \"TypeScript\" : \"Unknown\",\n\"getTypeSystem\"), oT = /* @__PURE__ */ r((e) => {\n  let n = ys(e[0]), a = zt(n);\n  return e.map((s) => {\n    let p = s;\n    return s.type?.elements && (p = {\n      ...s,\n      type: {\n        ...s.type,\n        value: s.type.elements\n      }\n    }), ds(p.name, p, n, a);\n  });\n}, \"extractComponentSectionArray\"), aT = /* @__PURE__ */ r((e) => {\n  let n = Object.keys(e), a = ys(e[n[0]]), s = zt(a);\n  return n.map((p) => {\n    let c = e[p];\n    return c != null ? ds(p, c, a, s) : null;\n  }).filter(Boolean);\n}, \"extractComponentSectionObject\"), Bw = /* @__PURE__ */ r((e, n) => {\n  let a = $i(e, n);\n  return Bi(a) ? Array.isArray(a) ? oT(a) : aT(a) : [];\n}, \"extractComponentProps\");\nfunction ds(e, n, a, s) {\n  let p = Zi(n.description);\n  return p.includesJsDoc && p.ignore ? null : {\n    propDef: s(e, n, p),\n    jsDocTags: p.extractedTags,\n    docgenInfo: n,\n    typeSystem: a\n  };\n}\nr(ds, \"extractProp\");\nfunction $w(e) {\n  return e != null ? Gi(e) : \"\";\n}\nr($w, \"extractComponentDescription\");\n\n// src/docs-tools/argTypes/enhanceArgTypes.ts\nimport { combineParameters as iT } from \"@storybook/core/preview-api\";\nvar zw = /* @__PURE__ */ r((e) => {\n  let {\n    component: n,\n    argTypes: a,\n    parameters: { docs: s = {} }\n  } = e, { extractArgTypes: p } = s, c = p && n ? p(n) : {};\n  return c ? iT(c, a) : a;\n}, \"enhanceArgTypes\");\n\n// src/docs-tools/shared.ts\nvar ms = \"storybook/docs\", Qw = `${ms}/panel`, Zw = \"docs\", eP = `${ms}/snippet-rendered`, sT = /* @__PURE__ */ ((s) => (s.AUTO = \"auto\", s.\nCODE = \"code\", s.DYNAMIC = \"dynamic\", s))(sT || {});\n\n// src/docs-tools/hasDocsOrControls.ts\nvar pT = /(addons\\/|addon-|addon-essentials\\/)(docs|controls)/, rP = /* @__PURE__ */ r((e) => e.presetsList?.some((n) => pT.test(n.name)), \"\\\nhasDocsOrControls\");\nexport {\n  ms as ADDON_ID,\n  pw as MAX_DEFAULT_VALUE_SUMMARY_LENGTH,\n  sw as MAX_TYPE_SUMMARY_LENGTH,\n  Qw as PANEL_ID,\n  Zw as PARAM_KEY,\n  eP as SNIPPET_RENDERED,\n  sT as SourceType,\n  Pm as TypeSystem,\n  He as convert,\n  O as createSummaryValue,\n  zw as enhanceArgTypes,\n  $w as extractComponentDescription,\n  Bw as extractComponentProps,\n  oT as extractComponentSectionArray,\n  aT as extractComponentSectionObject,\n  Gi as getDocgenDescription,\n  $i as getDocgenSection,\n  Ki as hasDocgen,\n  rP as hasDocsOrControls,\n  ye as isDefaultValueBlacklisted,\n  os as isTooLongForDefaultValueSummary,\n  Ht as isTooLongForTypeSummary,\n  Bi as isValidDocgenSection,\n  cw as normalizeNewlines,\n  Zi as parseJsDoc,\n  Vi as str\n};\n"],"names":[],"sourceRoot":""}